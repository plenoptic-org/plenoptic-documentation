

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>plenoptic.synthesize.metamer &mdash; plenoptic 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

<div style="background-color: rgb(248, 215, 218); color: rgb(114, 28, 36); text-align: center;">
  <div>
    <div>This is documentation for <strong>an old version</strong>.
      <a href="https://docs.plenoptic.org/" style="background-color: rgb(220, 53, 69); color: rgb(255, 255, 255); margin: 1rem; padding: 0.375rem 0.75rem; border-radius: 4px; display: inline-block; text-align: center;">Switch to stable version</a>
    </div>
  </div>
</div>
 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            plenoptic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conceptual_intro.html">Conceptual Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Model requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/00_quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Synthesis method introductions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/intro/02_Eigendistortions.html">Eigendistortions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/intro/05_Geodesics.html">Representational Geodesic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/intro/06_Metamer.html">Metamers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/intro/07_Simple_MAD.html">MAD Competition Conceptual Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/intro/08_MAD_Competition.html">MAD Competition Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models and metrics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/models/03_Steerable_Pyramid.html">Steerable Pyramid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/models/04_Perceptual_distance.html">Perceptual distance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/models/Metamer-Portilla-Simoncelli.html">Portilla-Simoncelli Texture Metamer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Synthesis method examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/applications/09_Original_MAD.html">Reproducing Wang and Simoncelli, 2008 (MAD Competition)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/applications/Demo_Eigendistortion.html">Reproducing Berardino et al., 2017 (Eigendistortions)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../synthesis.html">Synthesis object design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tips.html">Tips and Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reproducibility.html">Reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/advanced/Display.html">Display and animate functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/advanced/Synthesis_extensions.html">Extending existing synthesis objects</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">plenoptic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">plenoptic.synthesize.metamer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for plenoptic.synthesize.metamer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Synthesize model metamers.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">..tools</span> <span class="kn">import</span> <span class="n">optim</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">data</span>
<span class="kn">from</span> <span class="nn">..tools.validate</span> <span class="kn">import</span> <span class="n">validate_input</span><span class="p">,</span> <span class="n">validate_model</span><span class="p">,</span> <span class="n">validate_coarse_to_fine</span>
<span class="kn">from</span> <span class="nn">..tools.convergence</span> <span class="kn">import</span> <span class="n">coarse_to_fine_enough</span><span class="p">,</span> <span class="n">loss_convergence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="nn">.synthesis</span> <span class="kn">import</span> <span class="n">OptimizedSynthesis</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>


<div class="viewcode-block" id="Metamer">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.Metamer">[docs]</a>
<span class="k">class</span> <span class="nc">Metamer</span><span class="p">(</span><span class="n">OptimizedSynthesis</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Synthesize metamers for image-computable differentiable models.</span>

<span class="sd">    Following the basic idea in [1]_, this class creates a metamer for a given</span>
<span class="sd">    model on a given image. We start with ``initial_image`` and iteratively</span>
<span class="sd">    adjust the pixel values so as to match the representation of the</span>
<span class="sd">    ``metamer`` and ``image``.</span>

<span class="sd">    All ``saved_`` attributes are initialized as empty lists and will be</span>
<span class="sd">    non-empty if the ``store_progress`` arg to ``synthesize()`` is not</span>
<span class="sd">    ``False``. They will be appended to on every iteration if</span>
<span class="sd">    ``store_progress=True`` or every ``store_progress`` iterations if it&#39;s an</span>
<span class="sd">    ``int``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image :</span>
<span class="sd">        A 4d tensor, this is the image whose representation we wish to</span>
<span class="sd">        match. If this is not a tensor, we try to cast it as one.</span>
<span class="sd">    model :</span>
<span class="sd">        A visual model, see `Metamer` notebook for more details</span>
<span class="sd">    loss_function :</span>
<span class="sd">        the loss function to use to compare the representations of the models</span>
<span class="sd">        in order to determine their loss. Because of the limitations of pickle,</span>
<span class="sd">        you cannot use a lambda function for this if you wish to save the</span>
<span class="sd">        Metamer object (i.e., it must be one of our built-in functions or</span>
<span class="sd">        defined using a `def` statement)</span>
<span class="sd">    range_penalty_lambda :</span>
<span class="sd">        strength of the regularizer that enforces the allowed_range. Must be</span>
<span class="sd">        non-negative.</span>
<span class="sd">    allowed_range :</span>
<span class="sd">        Range (inclusive) of allowed pixel values. Any values outside this</span>
<span class="sd">        range will be penalized.</span>
<span class="sd">    initial_image :</span>
<span class="sd">        4d Tensor to initialize our metamer with. If None, will draw a sample</span>
<span class="sd">        of uniform noise within ``allowed_range``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    target_representation : torch.Tensor</span>
<span class="sd">        Whatever is returned by ``model(image)``, this is what we match</span>
<span class="sd">        in order to create a metamer</span>
<span class="sd">    metamer : torch.Tensor</span>
<span class="sd">        The metamer. This may be unfinished depending on how many</span>
<span class="sd">        iterations we&#39;ve run for.</span>
<span class="sd">    losses : list</span>
<span class="sd">        A list of our loss over iterations.</span>
<span class="sd">    gradient_norm : list</span>
<span class="sd">        A list of the gradient&#39;s L2 norm over iterations.</span>
<span class="sd">    pixel_change_norm : list</span>
<span class="sd">        A list containing the L2 norm of the pixel change over iterations</span>
<span class="sd">        (``pixel_change_norm[i]`` is the pixel change norm in</span>
<span class="sd">        ``metamer`` between iterations ``i`` and ``i-1``).</span>
<span class="sd">    saved_metamer : torch.Tensor</span>
<span class="sd">        Saved ``self.metamer`` for later examination.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J Portilla and E P Simoncelli. A Parametric Texture Model</span>
<span class="sd">       based on Joint Statistics of Complex Wavelet Coefficients. Int&#39;l</span>
<span class="sd">       Journal of Computer Vision. 40(1):49-71, October, 2000.</span>
<span class="sd">       http://www.cns.nyu.edu/~eero/ABSTRACTS/portilla99-abstract.html</span>
<span class="sd">       http://www.cns.nyu.edu/~lcv/texture/</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                 <span class="n">loss_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">mse</span><span class="p">,</span>
                 <span class="n">range_penalty_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">,</span>
                 <span class="n">allowed_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">initial_image</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">range_penalty_lambda</span><span class="p">,</span> <span class="n">allowed_range</span><span class="p">)</span>
        <span class="n">validate_input</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">allowed_range</span><span class="o">=</span><span class="n">allowed_range</span><span class="p">)</span>
        <span class="n">validate_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">image_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">image_dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                       <span class="n">device</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_representation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_function</span> <span class="o">=</span> <span class="n">loss_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">(</span><span class="n">initial_image</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_progress</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_image</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the metamer.</span>

<span class="sd">        Set the ``self.metamer`` attribute to be an attribute with the</span>
<span class="sd">        user-supplied data, making sure it&#39;s the right shape.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_image :</span>
<span class="sd">            The tensor we use to initialize the metamer. If None (the default),</span>
<span class="sd">            we initialize with uniformly-distributed random noise lying between</span>
<span class="sd">            0 and 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">initial_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metamer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="c1"># rescale metamer to lie within the interval</span>
            <span class="c1"># self.allowed_range</span>
            <span class="n">metamer</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">allowed_range</span><span class="p">)</span>
            <span class="n">metamer</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initial_image</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;initial_image must be torch.Size([n_batch&quot;</span>
                                 <span class="s2">&quot;, n_channels, im_height, im_width]) but got &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">initial_image</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_image</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;initial_image and image must be same size!&quot;</span><span class="p">)</span>
            <span class="n">metamer</span> <span class="o">=</span> <span class="n">initial_image</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">metamer</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">metamer</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metamer</span> <span class="o">=</span> <span class="n">metamer</span>

<div class="viewcode-block" id="Metamer.synthesize">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.Metamer.synthesize">[docs]</a>
    <span class="k">def</span> <span class="nf">synthesize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                   <span class="n">optimizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">scheduler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">_LRScheduler</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">store_progress</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">stop_criterion</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                   <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Synthesize a metamer.</span>

<span class="sd">        Update the pixels of ``initial_image`` until its representation matches</span>
<span class="sd">        that of ``image``.</span>

<span class="sd">        We run this until either we reach ``max_iter`` or the change over the</span>
<span class="sd">        past ``stop_iters_to_check`` iterations is less than</span>
<span class="sd">        ``stop_criterion``, whichever comes first</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_iter :</span>
<span class="sd">            The maximum number of iterations to run before we end synthesis</span>
<span class="sd">            (unless we hit the stop criterion).</span>
<span class="sd">        optimizer :</span>
<span class="sd">            The optimizer to use. If None and this is the first time calling</span>
<span class="sd">            synthesize, we use Adam(lr=.01, amsgrad=True); if synthesize has</span>
<span class="sd">            been called before, this must be None and we reuse the previous</span>
<span class="sd">            optimizer.</span>
<span class="sd">        scheduler :</span>
<span class="sd">            The learning rate scheduler to use. If None, we don&#39;t use one.</span>
<span class="sd">        store_progress :</span>
<span class="sd">            Whether we should store the metamer image in progress on every</span>
<span class="sd">            iteration. If False, we don&#39;t save anything. If True, we save every</span>
<span class="sd">            iteration. If an int, we save every ``store_progress`` iterations</span>
<span class="sd">            (note then that 0 is the same as False and 1 the same as True).</span>
<span class="sd">        stop_criterion :</span>
<span class="sd">            If the loss over the past ``stop_iters_to_check`` has changed</span>
<span class="sd">            less than ``stop_criterion``, we terminate synthesis.</span>
<span class="sd">        stop_iters_to_check :</span>
<span class="sd">            How many iterations back to check in order to see if the</span>
<span class="sd">            loss has stopped decreasing (for ``stop_criterion``).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize the optimizer and scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_optimizer</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">)</span>

        <span class="c1"># get ready to store progress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_progress</span> <span class="o">=</span> <span class="n">store_progress</span>

        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="c1"># update saved_* attrs. len(losses) gives the total number of</span>
            <span class="c1"># iterations and will be correct across calls to `synthesize`</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">))</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer_step</span><span class="p">(</span><span class="n">pbar</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">loss</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found a NaN in loss during optimization.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convergence</span><span class="p">(</span><span class="n">stop_criterion</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Loss has converged, stopping synthesis&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="Metamer.objective_function">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.Metamer.objective_function">[docs]</a>
    <span class="k">def</span> <span class="nf">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metamer_representation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">target_representation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the metamer synthesis loss.</span>

<span class="sd">        This calls self.loss_function on ``metamer_representation`` and</span>
<span class="sd">        ``target_representation`` and then adds the weighted range penalty.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metamer_representation :</span>
<span class="sd">            Model response to ``metamer``. If None, we use</span>
<span class="sd">            ``self.model(self.metamer)``</span>
<span class="sd">        target_representation :</span>
<span class="sd">            Model response to ``image``. If None, we use</span>
<span class="sd">            ``self.target_representation``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loss</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metamer_representation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metamer_representation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target_representation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_representation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_representation</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_function</span><span class="p">(</span><span class="n">metamer_representation</span><span class="p">,</span>
                                  <span class="n">target_representation</span><span class="p">)</span>
        <span class="n">range_penalty</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">penalize_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">allowed_range</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_penalty_lambda</span> <span class="o">*</span> <span class="n">range_penalty</span></div>


    <span class="k">def</span> <span class="nf">_optimizer_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbar</span><span class="p">:</span> <span class="n">tqdm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute and propagate gradients, then step the optimizer to update metamer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbar :</span>
<span class="sd">            A tqdm progress-bar, which we update with a postfix</span>
<span class="sd">            describing the current loss, gradient norm, and learning</span>
<span class="sd">            rate (it already tells us which iteration and the time</span>
<span class="sd">            elapsed).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loss : torch.Tensor</span>
<span class="sd">            1-element tensor containing the loss on this step</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_iter_metamer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_closure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="n">grad_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                             <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grad_norm</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="c1"># optionally step the scheduler</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="n">pixel_change_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span> <span class="o">-</span> <span class="n">last_iter_metamer</span><span class="p">,</span>
                                                     <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_change_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pixel_change_norm</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="c1"># add extra info here if you want it to show up in progress bar</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">(</span>
            <span class="n">OrderedDict</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.04e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;lr&#39;</span><span class="p">],</span>
                        <span class="n">gradient_norm</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">grad_norm</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.04e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">pixel_change_norm</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pixel_change_norm</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.04e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">loss</span>

    <span class="k">def</span> <span class="nf">_check_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stop_criterion</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check whether the loss has stabilized and, if so, return True.</span>

<span class="sd">         Have we been synthesizing for ``stop_iters_to_check`` iterations?</span>
<span class="sd">         | |</span>
<span class="sd">        no yes</span>
<span class="sd">         | &#39;----&gt;Is ``abs(synth.loss[-1] - synth.losses[-stop_iters_to_check]) &lt; stop_criterion``?</span>
<span class="sd">         |      no |</span>
<span class="sd">         |       | yes</span>
<span class="sd">         &lt;-------&#39; |</span>
<span class="sd">         |         &#39;------&gt; return ``True``</span>
<span class="sd">         |</span>
<span class="sd">         &#39;---------&gt; return ``False``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stop_criterion :</span>
<span class="sd">            If the loss over the past ``stop_iters_to_check`` has changed</span>
<span class="sd">            less than ``stop_criterion``, we terminate synthesis.</span>
<span class="sd">        stop_iters_to_check :</span>
<span class="sd">            How many iterations back to check in order to see if the</span>
<span class="sd">            loss has stopped decreasing (for ``stop_criterion``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loss_stabilized :</span>
<span class="sd">            Whether the loss has stabilized or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">loss_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stop_criterion</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_optimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">optimizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">],</span>
                              <span class="n">scheduler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">_LRScheduler</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize optimizer and scheduler.&quot;&quot;&quot;</span>
        <span class="c1"># this uses the OptimizedSynthesis setter</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_initialize_optimizer</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="s1">&#39;metamer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">scheduler</span>
        <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">:</span>
            <span class="c1"># initialize initial_lr if it&#39;s not here. Scheduler should add it</span>
            <span class="c1"># if it&#39;s not None.</span>
            <span class="k">if</span> <span class="s1">&#39;initial_lr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pg</span><span class="p">:</span>
                <span class="n">pg</span><span class="p">[</span><span class="s1">&#39;initial_lr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pg</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store metamer, if appropriate.</span>

<span class="sd">        if it&#39;s the right iteration, we update ``saved_metamer``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i</span>
<span class="sd">            the current iteration</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stored :</span>
<span class="sd">            True if we stored this iteration, False if not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_progress</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_progress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># want these to always be on cpu, to reduce memory use for GPUs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">))</span>
            <span class="n">stored</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stored</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">stored</span>

<div class="viewcode-block" id="Metamer.save">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.Metamer.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Save all relevant variables in .pt file.</span>

<span class="sd">        Note that if store_progress is True, this will probably be very</span>
<span class="sd">        large.</span>

<span class="sd">        See ``load`` docstring for an example of use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str</span>
<span class="sd">            The path to save the metamer object to</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Metamer.to">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.Metamer.to">[docs]</a>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Moves and/or casts the parameters and buffers.</span>

<span class="sd">        This can be called as</span>

<span class="sd">        .. function:: to(device=None, dtype=None, non_blocking=False)</span>

<span class="sd">        .. function:: to(dtype, non_blocking=False)</span>

<span class="sd">        .. function:: to(tensor, non_blocking=False)</span>

<span class="sd">        Its signature is similar to :meth:`torch.Tensor.to`, but only accepts</span>
<span class="sd">        floating point desired :attr:`dtype` s. In addition, this method will</span>
<span class="sd">        only cast the floating point parameters and buffers to :attr:`dtype`</span>
<span class="sd">        (if given). The integral parameters and buffers will be moved</span>
<span class="sd">        :attr:`device`, if that is given, but with dtypes unchanged. When</span>
<span class="sd">        :attr:`non_blocking` is set, it tries to convert/move asynchronously</span>
<span class="sd">        with respect to the host if possible, e.g., moving CPU Tensors with</span>
<span class="sd">        pinned memory to CUDA devices.</span>

<span class="sd">        See below for examples.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method modifies the module in-place.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (:class:`torch.device`): the desired device of the parameters</span>
<span class="sd">                and buffers in this module</span>
<span class="sd">            dtype (:class:`torch.dtype`): the desired floating point type of</span>
<span class="sd">                the floating point parameters and buffers in this module</span>
<span class="sd">            tensor (torch.Tensor): Tensor whose dtype and device are the desired</span>
<span class="sd">                dtype and device for all parameters and buffers in this module</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_image&#39;</span><span class="p">,</span> <span class="s1">&#39;_target_representation&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_metamer&#39;</span><span class="p">,</span> <span class="s1">&#39;_model&#39;</span><span class="p">,</span> <span class="s1">&#39;_saved_metamer&#39;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Metamer.load">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.Metamer.load">[docs]</a>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">map_location</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">pickle_load_args</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Load all relevant stuff from a .pt file.</span>

<span class="sd">        This should be called by an initialized ``Metamer`` object -- we will</span>
<span class="sd">        ensure that ``image``, ``target_representation`` (and thus</span>
<span class="sd">        ``model``), and ``loss_function`` are all identical.</span>

<span class="sd">        Note this operates in place and so doesn&#39;t return anything.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str</span>
<span class="sd">            The path to load the synthesis object from</span>
<span class="sd">        map_location : str, optional</span>
<span class="sd">            map_location argument to pass to ``torch.load``. If you save</span>
<span class="sd">            stuff that was being run on a GPU and are loading onto a</span>
<span class="sd">            CPU, you&#39;ll need this to make sure everything lines up</span>
<span class="sd">            properly. This should be structured like the str you would</span>
<span class="sd">            pass to ``torch.device``</span>
<span class="sd">        pickle_load_args :</span>
<span class="sd">            any additional kwargs will be added to ``pickle_module.load`` via</span>
<span class="sd">            ``torch.load``, see that function&#39;s docstring for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; metamer = po.synth.Metamer(img, model)</span>
<span class="sd">        &gt;&gt;&gt; metamer.synthesize(max_iter=10, store_progress=True)</span>
<span class="sd">        &gt;&gt;&gt; metamer.save(&#39;metamers.pt&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metamer_copy = po.synth.Metamer(img, model)</span>
<span class="sd">        &gt;&gt;&gt; metamer_copy.load(&#39;metamers.pt&#39;)</span>

<span class="sd">        Note that you must create a new instance of the Synthesis object and</span>
<span class="sd">        *then* load.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">map_location</span><span class="p">,</span> <span class="o">**</span><span class="n">pickle_load_args</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
              <span class="n">map_location</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">additional_check_attributes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
              <span class="n">additional_check_loss_functions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
              <span class="o">**</span><span class="n">pickle_load_args</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Helper function for loading.</span>

<span class="sd">        Users interact with ``load`` (without the underscore), this is to allow</span>
<span class="sd">        subclasses to specify additional attributes or loss functions to check.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_image&#39;</span><span class="p">,</span> <span class="s1">&#39;_target_representation&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;_range_penalty_lambda&#39;</span><span class="p">,</span> <span class="s1">&#39;_allowed_range&#39;</span><span class="p">]</span>
        <span class="n">check_attributes</span> <span class="o">+=</span> <span class="n">additional_check_attributes</span>
        <span class="n">check_loss_functions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;loss_function&#39;</span><span class="p">]</span>
        <span class="n">check_loss_functions</span> <span class="o">+=</span> <span class="n">additional_check_loss_functions</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="n">map_location</span><span class="p">,</span>
                     <span class="n">check_attributes</span><span class="o">=</span><span class="n">check_attributes</span><span class="p">,</span>
                     <span class="n">check_loss_functions</span><span class="o">=</span><span class="n">check_loss_functions</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">pickle_load_args</span><span class="p">)</span>
        <span class="c1"># make this require a grad again</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
        <span class="c1"># these are always supposed to be on cpu, but may get copied over to</span>
        <span class="c1"># gpu on load (which can cause problems when resuming synthesis), so</span>
        <span class="c1"># fix that.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;cpu&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span> <span class="o">=</span> <span class="p">[</span><span class="n">met</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">met</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Model representation of ``image``, the goal of synthesis is for ``model(metamer)`` to match this value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_representation</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metamer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metamer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">saved_metamer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_saved_metamer</span><span class="p">)</span></div>



<div class="viewcode-block" id="MetamerCTF">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.MetamerCTF">[docs]</a>
<span class="k">class</span> <span class="nc">MetamerCTF</span><span class="p">(</span><span class="n">Metamer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Synthesize model metamers with coarse-to-fine synthesis.</span>

<span class="sd">    This is a special case of ``Metamer``, which uses the coarse-to-fine</span>
<span class="sd">    synthesis procedure described in [1]_: we start by updating metamer with</span>
<span class="sd">    respect to only a subset of the model&#39;s representation (generally, that</span>
<span class="sd">    which corresponds to the lowest spatial frequencies), and changing which</span>
<span class="sd">    subset we consider over the course of synthesis. This is similar to</span>
<span class="sd">    optimizing with a blurred version of the objective function and gradually</span>
<span class="sd">    adding in finer details. It improves synthesis performance for some models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image :</span>
<span class="sd">        A 4d tensor, this is the image whose representation we wish to</span>
<span class="sd">        match. If this is not a tensor, we try to cast it as one.</span>
<span class="sd">    model :</span>
<span class="sd">        A visual model, see `Metamer` notebook for more details</span>
<span class="sd">    loss_function :</span>
<span class="sd">        the loss function to use to compare the representations of the models</span>
<span class="sd">        in order to determine their loss. Because of the limitations of pickle,</span>
<span class="sd">        you cannot use a lambda function for this if you wish to save the</span>
<span class="sd">        Metamer object (i.e., it must be one of our built-in functions or</span>
<span class="sd">        defined using a `def` statement)</span>
<span class="sd">    range_penalty_lambda :</span>
<span class="sd">        strength of the regularizer that enforces the allowed_range. Must be</span>
<span class="sd">        non-negative.</span>
<span class="sd">    allowed_range :</span>
<span class="sd">        Range (inclusive) of allowed pixel values. Any values outside this</span>
<span class="sd">        range will be penalized.</span>
<span class="sd">    initial_image :</span>
<span class="sd">        4d Tensor to initialize our metamer with. If None, will draw a sample</span>
<span class="sd">        of uniform noise within ``allowed_range``.</span>
<span class="sd">    coarse_to_fine :</span>
<span class="sd">        - &#39;together&#39;: start with the coarsest scale, then gradually</span>
<span class="sd">          add each finer scale.</span>
<span class="sd">        - &#39;separate&#39;: compute the gradient with respect to each</span>
<span class="sd">          scale separately (ignoring the others), then with respect</span>
<span class="sd">          to all of them at the end.</span>
<span class="sd">        (see ``Metamer`` tutorial for more details).</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    target_representation : torch.Tensor</span>
<span class="sd">        Whatever is returned by ``model(image)``, this is what we match</span>
<span class="sd">        in order to create a metamer</span>
<span class="sd">    metamer : torch.Tensor</span>
<span class="sd">        The metamer. This may be unfinished depending on how many</span>
<span class="sd">        iterations we&#39;ve run for.</span>
<span class="sd">    losses : list</span>
<span class="sd">        A list of our loss over iterations.</span>
<span class="sd">    gradient_norm : list</span>
<span class="sd">        A list of the gradient&#39;s L2 norm over iterations.</span>
<span class="sd">    pixel_change_norm : list</span>
<span class="sd">        A list containing the L2 norm of the pixel change over iterations</span>
<span class="sd">        (``pixel_change_norm[i]`` is the pixel change norm in</span>
<span class="sd">        ``metamer`` between iterations ``i`` and ``i-1``).</span>
<span class="sd">    saved_metamer : torch.Tensor</span>
<span class="sd">        Saved ``self.metamer`` for later examination.</span>
<span class="sd">    scales : list or None</span>
<span class="sd">        The list of scales in optimization order (i.e., from coarse to fine).</span>
<span class="sd">        Will be modified during the course of optimization.</span>
<span class="sd">    scales_loss : list or None</span>
<span class="sd">        The scale-specific loss at each iteration</span>
<span class="sd">    scales_timing : dict or None</span>
<span class="sd">        Keys are the values found in ``scales``, values are lists, specifying</span>
<span class="sd">        the iteration where we started and stopped optimizing this scale.</span>
<span class="sd">    scales_finished : list or None</span>
<span class="sd">        List of scales that we&#39;ve finished optimizing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                 <span class="n">loss_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">mse</span><span class="p">,</span>
                 <span class="n">range_penalty_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">,</span>
                 <span class="n">allowed_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">initial_image</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">coarse_to_fine</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;together&#39;</span><span class="p">,</span> <span class="s1">&#39;separate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;together&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">loss_function</span><span class="p">,</span> <span class="n">range_penalty_lambda</span><span class="p">,</span>
                         <span class="n">allowed_range</span><span class="p">,</span> <span class="n">initial_image</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_ctf</span><span class="p">(</span><span class="n">coarse_to_fine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_ctf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coarse_to_fine</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;together&#39;</span><span class="p">,</span> <span class="s1">&#39;separate&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize stuff related to coarse-to-fine.&quot;&quot;&quot;</span>
        <span class="c1"># this will hold the reduced representation of the target image.</span>
        <span class="k">if</span> <span class="n">coarse_to_fine</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;separate&#39;</span><span class="p">,</span> <span class="s1">&#39;together&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to handle value </span><span class="si">{</span><span class="n">coarse_to_fine</span><span class="si">}</span><span class="s2">!&quot;</span>
                             <span class="s2">&quot; Must be one of: &#39;separate&#39;, &#39;together&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ctf_target_representation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">validate_coarse_to_fine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">image_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># if self.scales is not None, we&#39;re continuing a previous version</span>
        <span class="c1"># and want to continue. this list comprehension creates a new</span>
        <span class="c1"># object, so we don&#39;t modify model.scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scales</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">coarse_to_fine</span> <span class="o">==</span> <span class="s1">&#39;separate&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scales</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales_timing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales_timing</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales_loss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales_finished</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coarse_to_fine</span> <span class="o">=</span> <span class="n">coarse_to_fine</span>

<div class="viewcode-block" id="MetamerCTF.synthesize">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.MetamerCTF.synthesize">[docs]</a>
    <span class="k">def</span> <span class="nf">synthesize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                   <span class="n">optimizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">scheduler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">_LRScheduler</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">store_progress</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">stop_criterion</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                   <span class="n">change_scale_criterion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">,</span>
                   <span class="n">ctf_iters_to_check</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                   <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Synthesize a metamer.</span>

<span class="sd">        Update the pixels of ``initial_image`` until its representation matches</span>
<span class="sd">        that of ``image``.</span>

<span class="sd">        We run this until either we reach ``max_iter`` or the change over the</span>
<span class="sd">        past ``stop_iters_to_check`` iterations is less than</span>
<span class="sd">        ``stop_criterion``, whichever comes first</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_iter :</span>
<span class="sd">            The maximum number of iterations to run before we end synthesis</span>
<span class="sd">            (unless we hit the stop criterion).</span>
<span class="sd">        optimizer :</span>
<span class="sd">            The optimizer to use. If None and this is the first time calling</span>
<span class="sd">            synthesize, we use Adam(lr=.01, amsgrad=True); if synthesize has</span>
<span class="sd">            been called before, this must be None and we reuse the previous</span>
<span class="sd">            optimizer.</span>
<span class="sd">        scheduler :</span>
<span class="sd">            The learning rate scheduler to use. If None, we don&#39;t use one.</span>
<span class="sd">        store_progress :</span>
<span class="sd">            Whether we should store the metamer image in progress on every</span>
<span class="sd">            iteration. If False, we don&#39;t save anything. If True, we save every</span>
<span class="sd">            iteration. If an int, we save every ``store_progress`` iterations</span>
<span class="sd">            (note then that 0 is the same as False and 1 the same as True).</span>
<span class="sd">        stop_criterion :</span>
<span class="sd">            If the loss over the past ``stop_iters_to_check`` has changed</span>
<span class="sd">            less than ``stop_criterion``, we terminate synthesis.</span>
<span class="sd">        stop_iters_to_check :</span>
<span class="sd">            How many iterations back to check in order to see if the</span>
<span class="sd">            loss has stopped decreasing (for ``stop_criterion``).</span>
<span class="sd">        change_scale_criterion</span>
<span class="sd">            Scale-specific analogue of ``change_scale_criterion``: we consider</span>
<span class="sd">            a given scale finished (and move onto the next) if the loss has</span>
<span class="sd">            changed less than this in the past ``ctf_iters_to_check``</span>
<span class="sd">            iterations. If ``None``, we&#39;ll change scales as soon as we&#39;ve spent</span>
<span class="sd">            ``ctf_iters_to_check`` on a given scale</span>
<span class="sd">        ctf_iters_to_check</span>
<span class="sd">            Scale-specific analogue of ``stop_iters_to_check``: how many</span>
<span class="sd">            iterations back in order to check in order to see if we should</span>
<span class="sd">            switch scales.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">change_scale_criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">stop_criterion</span> <span class="o">&gt;=</span> <span class="n">change_scale_criterion</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stop_criterion must be strictly less than &quot;</span>
                             <span class="s2">&quot;change_scale_criterion, or things get weird!&quot;</span><span class="p">)</span>

        <span class="c1"># initialize the optimizer and scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_optimizer</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">)</span>

        <span class="c1"># get ready to store progress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_progress</span> <span class="o">=</span> <span class="n">store_progress</span>


        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="c1"># update saved_* attrs. len(losses) gives the total number of</span>
            <span class="c1"># iterations and will be correct across calls to `synthesize`</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">))</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer_step</span><span class="p">(</span><span class="n">pbar</span><span class="p">,</span> <span class="n">change_scale_criterion</span><span class="p">,</span> <span class="n">ctf_iters_to_check</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">loss</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found a NaN in loss during optimization.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convergence</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stop_criterion</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">,</span>
                                       <span class="n">ctf_iters_to_check</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Loss has converged, stopping synthesis&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_optimizer_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbar</span><span class="p">:</span> <span class="n">tqdm</span><span class="p">,</span>
                        <span class="n">change_scale_criterion</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                        <span class="n">ctf_iters_to_check</span><span class="p">:</span> <span class="nb">int</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute and propagate gradients, then step the optimizer to update metamer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbar :</span>
<span class="sd">            A tqdm progress-bar, which we update with a postfix</span>
<span class="sd">            describing the current loss, gradient norm, and learning</span>
<span class="sd">            rate (it already tells us which iteration and the time</span>
<span class="sd">            elapsed).</span>
<span class="sd">        change_scale_criterion :</span>
<span class="sd">            How many iterations back to check to see if the loss has stopped</span>
<span class="sd">            decreasing and we should thus move to the next scale in</span>
<span class="sd">            coarse-to-fine optimization.</span>
<span class="sd">        ctf_iters_to_check :</span>
<span class="sd">            Minimum number of iterations coarse-to-fine must run at each scale.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loss : torch.Tensor</span>
<span class="sd">            1-element tensor containing the loss on this step</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_iter_metamer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="c1"># The first check here is because the last scale will be &#39;all&#39;, and</span>
        <span class="c1"># we never remove it. Otherwise, check to see if it looks like loss</span>
        <span class="c1"># has stopped declining and, if so, switch to the next scale. Then</span>
        <span class="c1"># we&#39;re checking if self.scales_loss is long enough to check</span>
        <span class="c1"># ctf_iters_to_check back.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales_loss</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ctf_iters_to_check</span><span class="p">:</span>
            <span class="c1"># Now we check whether loss has decreased less than</span>
            <span class="c1"># change_scale_criterion</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">change_scale_criterion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales_loss</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scales_loss</span><span class="p">[</span><span class="o">-</span><span class="n">ctf_iters_to_check</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">change_scale_criterion</span><span class="p">):</span>
                <span class="c1"># and finally we check whether we&#39;ve been optimizing this</span>
                <span class="c1"># scale for ctf_iters_to_check</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scales_timing</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ctf_iters_to_check</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scales_timing</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scales_finished</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scales</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scales_timing</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">))</span>
                    <span class="c1"># reset optimizer&#39;s lr.</span>
                    <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">:</span>
                        <span class="n">pg</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pg</span><span class="p">[</span><span class="s1">&#39;initial_lr&#39;</span><span class="p">]</span>
                    <span class="c1"># reset ctf target representation, so we update it on</span>
                    <span class="c1"># next pass</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ctf_target_representation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">loss</span><span class="p">,</span> <span class="n">overall_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_closure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scales_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overall_loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="n">grad_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                             <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grad_norm</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="c1"># optionally step the scheduler</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="n">pixel_change_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">vector_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span> <span class="o">-</span> <span class="n">last_iter_metamer</span><span class="p">,</span>
                                                     <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_change_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pixel_change_norm</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="c1"># add extra info here if you want it to show up in progress bar</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">(</span>
            <span class="n">OrderedDict</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">overall_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.04e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;lr&#39;</span><span class="p">],</span>
                        <span class="n">gradient_norm</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">grad_norm</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.04e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">pixel_change_norm</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pixel_change_norm</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s2">.04e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">current_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">current_scale_loss</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">:</span><span class="s1">.04e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">overall_loss</span>

    <span class="k">def</span> <span class="nf">_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An abstraction of the gradient calculation, before the optimization step.</span>

<span class="sd">        This enables optimization algorithms that perform several evaluations</span>
<span class="sd">        of the gradient before taking a step (ie. second order methods like</span>
<span class="sd">        LBFGS).</span>

<span class="sd">        Additionally, this is where:</span>

<span class="sd">        - ``metamer_representation`` is calculated, and thus any modifications</span>
<span class="sd">          to the model&#39;s forward call (e.g., specifying `scale` kwarg for</span>
<span class="sd">          coarse-to-fine) should happen.</span>

<span class="sd">        - ``loss`` is calculated and ``loss.backward()`` is called.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loss</span>
<span class="sd">            Loss of the current objective function</span>
<span class="sd">        overall_loss</span>
<span class="sd">            Loss of the complete model. This differs from ``loss`` if we&#39;re</span>
<span class="sd">            doing coarse-to-fine synthesis</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">analyze_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># if we&#39;ve reached &#39;all&#39;, we use the full model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">analyze_kwargs</span><span class="p">[</span><span class="s1">&#39;scales&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># if &#39;together&#39;, then we also want all the coarser</span>
            <span class="c1"># scales</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coarse_to_fine</span> <span class="o">==</span> <span class="s1">&#39;together&#39;</span><span class="p">:</span>
                <span class="n">analyze_kwargs</span><span class="p">[</span><span class="s1">&#39;scales&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scales_finished</span>
        <span class="n">metamer_representation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metamer</span><span class="p">,</span> <span class="o">**</span><span class="n">analyze_kwargs</span><span class="p">)</span>
        <span class="c1"># if analyze_kwargs is empty, we can just compare</span>
        <span class="c1"># metamer_representation against our cached target_representation</span>
        <span class="k">if</span> <span class="n">analyze_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctf_target_representation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">target_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">analyze_kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ctf_target_representation</span> <span class="o">=</span> <span class="n">target_rep</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctf_target_representation</span>
            <span class="c1"># this is just for display, so don&#39;t compute gradients</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">overall_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_rep</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">overall_loss</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="n">metamer_representation</span><span class="p">,</span> <span class="n">target_rep</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overall_loss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overall_loss</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">overall_loss</span>

    <span class="k">def</span> <span class="nf">_check_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">stop_criterion</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">stop_iters_to_check</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">ctf_iters_to_check</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check whether the loss has stabilized and whether we&#39;ve synthesized all scales.</span>

<span class="sd">         Have we been synthesizing for ``stop_iters_to_check`` iterations?</span>
<span class="sd">         | |</span>
<span class="sd">        no yes</span>
<span class="sd">         | &#39;----&gt;Is ``abs(self.loss[-1] - self.losses[-stop_iters_to_check] &lt; stop_criterion``?</span>
<span class="sd">         |      no |</span>
<span class="sd">         |       | yes</span>
<span class="sd">         |-------&#39; &#39;----&gt;Have we synthesized all scales and done so for ``ctf_iters_to_check`` iterations?</span>
<span class="sd">         |              no  |</span>
<span class="sd">         |               |  yes</span>
<span class="sd">         |---------------&#39;  &#39;----&gt; return ``True``</span>
<span class="sd">         |</span>
<span class="sd">         |</span>
<span class="sd">         |</span>
<span class="sd">         |</span>
<span class="sd">         |</span>
<span class="sd">         |</span>
<span class="sd">         &#39;---------&gt; return ``False``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i</span>
<span class="sd">            The current iteration (0-indexed).</span>
<span class="sd">        stop_criterion</span>
<span class="sd">            If the loss over the past ``stop_iters_to_check`` has changed</span>
<span class="sd">            less than ``stop_criterion``, we terminate synthesis.</span>
<span class="sd">        stop_iters_to_check</span>
<span class="sd">            How many iterations back to check in order to see if the</span>
<span class="sd">            loss has stopped decreasing (for ``stop_criterion``).</span>
<span class="sd">        ctf_iters_to_check</span>
<span class="sd">            Minimum number of iterations coarse-to-fine must run at each scale.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loss_stabilized :</span>
<span class="sd">            Whether the loss has stabilized and we&#39;ve synthesized all scales.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loss_conv</span> <span class="o">=</span> <span class="n">loss_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stop_criterion</span><span class="p">,</span> <span class="n">stop_iters_to_check</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss_conv</span> <span class="ow">and</span> <span class="n">coarse_to_fine_enough</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctf_iters_to_check</span><span class="p">)</span>

<div class="viewcode-block" id="MetamerCTF.load">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.MetamerCTF.load">[docs]</a>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">map_location</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">pickle_load_args</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Load all relevant stuff from a .pt file.</span>

<span class="sd">        This should be called by an initialized ``Metamer`` object -- we will</span>
<span class="sd">        ensure that ``image``, ``target_representation`` (and thus</span>
<span class="sd">        ``model``), and ``loss_function`` are all identical.</span>

<span class="sd">        Note this operates in place and so doesn&#39;t return anything.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str</span>
<span class="sd">            The path to load the synthesis object from</span>
<span class="sd">        map_location : str, optional</span>
<span class="sd">            map_location argument to pass to ``torch.load``. If you save</span>
<span class="sd">            stuff that was being run on a GPU and are loading onto a</span>
<span class="sd">            CPU, you&#39;ll need this to make sure everything lines up</span>
<span class="sd">            properly. This should be structured like the str you would</span>
<span class="sd">            pass to ``torch.device``</span>
<span class="sd">        pickle_load_args :</span>
<span class="sd">            any additional kwargs will be added to ``pickle_module.load`` via</span>
<span class="sd">            ``torch.load``, see that function&#39;s docstring for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; metamer = po.synth.Metamer(img, model)</span>
<span class="sd">        &gt;&gt;&gt; metamer.synthesize(max_iter=10, store_progress=True)</span>
<span class="sd">        &gt;&gt;&gt; metamer.save(&#39;metamers.pt&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metamer_copy = po.synth.Metamer(img, model)</span>
<span class="sd">        &gt;&gt;&gt; metamer_copy.load(&#39;metamers.pt&#39;)</span>

<span class="sd">        Note that you must create a new instance of the Synthesis object and</span>
<span class="sd">        *then* load.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">map_location</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;_coarse_to_fine&#39;</span><span class="p">],</span>
                      <span class="o">**</span><span class="n">pickle_load_args</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coarse_to_fine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coarse_to_fine</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scales</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scales</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scales_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scales_loss</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scales_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scales_timing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scales_finished</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scales_finished</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_loss">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.plot_loss">[docs]</a>
<span class="k">def</span> <span class="nf">plot_loss</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
              <span class="n">iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot synthesis loss with log-scaled y axis.</span>

<span class="sd">    Plots ``metamer.losses`` over all iterations. Also plots a red dot at</span>
<span class="sd">    ``iteration``, to highlight the loss there. If ``iteration=None``, then the</span>
<span class="sd">    dot will be at the final iteration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object whose loss we want to plot.</span>
<span class="sd">    iteration :</span>
<span class="sd">        Which iteration to display. If None, the default, we show</span>
<span class="sd">        the most recent one. Negative values are also allowed.</span>
<span class="sd">    ax :</span>
<span class="sd">        Pre-existing axes for plot. If None, we call ``plt.gca()``.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        passed to plt.semilogy</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax :</span>
<span class="sd">        The matplotlib axes containing the plot.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loss_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">losses</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># in order to get the x-value of the dot to line up,</span>
            <span class="c1"># need to use this work-around</span>
            <span class="n">loss_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">losses</span><span class="p">)</span> <span class="o">+</span> <span class="n">iteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss_idx</span> <span class="o">=</span> <span class="n">iteration</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">losses</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">loss_idx</span><span class="p">,</span> <span class="n">metamer</span><span class="o">.</span><span class="n">losses</span><span class="p">[</span><span class="n">loss_idx</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="c1"># then there&#39;s no loss here</span>
        <span class="k">pass</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Synthesis iteration&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Loss&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>



<div class="viewcode-block" id="display_metamer">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.display_metamer">[docs]</a>
<span class="k">def</span> <span class="nf">display_metamer</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
                    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">channel_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">zoom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Display metamer.</span>

<span class="sd">    You can specify what iteration to view by using the ``iteration`` arg.</span>
<span class="sd">    The default, ``None``, shows the final one.</span>

<span class="sd">    We use ``plenoptic.imshow`` to display the metamer and attempt to</span>
<span class="sd">    automatically find the most reasonable zoom value. You can override this</span>
<span class="sd">    value using the zoom arg, but remember that ``plenoptic.imshow`` is</span>
<span class="sd">    opinionated about the size of the resulting image and will throw an</span>
<span class="sd">    Exception if the axis created is not big enough for the selected zoom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object whose synthesized metamer we want to display.</span>
<span class="sd">    batch_idx :</span>
<span class="sd">        Which index to take from the batch dimension</span>
<span class="sd">    channel_idx :</span>
<span class="sd">        Which index to take from the channel dimension. If None, we assume</span>
<span class="sd">        image is RGB(A) and show all channels.</span>
<span class="sd">    iteration :</span>
<span class="sd">        Which iteration to display. If None, the default, we show</span>
<span class="sd">        the most recent one. Negative values are also allowed.</span>
<span class="sd">    ax :</span>
<span class="sd">        Pre-existing axes for plot. If None, we call ``plt.gca()``.</span>
<span class="sd">    zoom :</span>
<span class="sd">        How much to zoom in / enlarge the metamer, the ratio of display pixels</span>
<span class="sd">        to image pixels. If None (the default), we attempt to find the best</span>
<span class="sd">        value ourselves.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Passed to ``plenoptic.imshow``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax :</span>
<span class="sd">        The matplotlib axes containing the plot.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">metamer</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">batch_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;batch_idx must be an integer!&quot;</span><span class="p">)</span>
    <span class="c1"># we&#39;re only plotting one image here, so if the user wants multiple</span>
    <span class="c1"># channels, they must be RGB</span>
    <span class="k">if</span> <span class="n">channel_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">as_rgb</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">as_rgb</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">display</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Metamer&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">,</span>
                   <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span> <span class="n">channel_idx</span><span class="o">=</span><span class="n">channel_idx</span><span class="p">,</span>
                   <span class="n">as_rgb</span><span class="o">=</span><span class="n">as_rgb</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>



<span class="k">def</span> <span class="nf">_representation_error</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
                          <span class="n">iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the representation error.</span>

<span class="sd">    This is ``metamer.model(metamer) - target_representation)``. If</span>
<span class="sd">    ``iteration`` is not None, we use</span>
<span class="sd">    ``metamer.model(saved_metamer[iteration])`` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object whose representation error we want to compute.</span>
<span class="sd">    iteration :</span>
<span class="sd">        Which iteration to compute the representation error for. If None, we</span>
<span class="sd">        show the most recent one. Negative values are also allowed.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Passed to ``metamer.model.forward``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    representation_error</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">metamer_rep</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">target_representation</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">metamer_rep</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">metamer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">metamer_rep</span> <span class="o">-</span> <span class="n">metamer</span><span class="o">.</span><span class="n">target_representation</span>


<div class="viewcode-block" id="plot_representation_error">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.plot_representation_error">[docs]</a>
<span class="k">def</span> <span class="nf">plot_representation_error</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
                              <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">ylim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">as_rgb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Plot distance ratio showing how close we are to convergence.</span>

<span class="sd">    We plot ``_representation_error(metamer, iteration)``. For more details, see</span>
<span class="sd">    ``plenoptic.tools.display.plot_representation``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object whose synthesized metamer we want to display.</span>
<span class="sd">    batch_idx :</span>
<span class="sd">        Which index to take from the batch dimension</span>
<span class="sd">    iteration :</span>
<span class="sd">        Which iteration to display. If None, the default, we show</span>
<span class="sd">        the most recent one. Negative values are also allowed.</span>
<span class="sd">    ylim :</span>
<span class="sd">        If ``ylim`` is ``None``, we sets the axes&#39; y-limits to be ``(-y_max,</span>
<span class="sd">        y_max)``, where ``y_max=np.abs(data).max()``. If it&#39;s ``False``, we do</span>
<span class="sd">        nothing. If a tuple, we use that range.</span>
<span class="sd">    ax :</span>
<span class="sd">        Pre-existing axes for plot. If None, we call ``plt.gca()``.</span>
<span class="sd">    as_rgb : bool, optional</span>
<span class="sd">        The representation can be image-like with multiple channels, and we</span>
<span class="sd">        have no way to determine whether it should be represented as an RGB</span>
<span class="sd">        image or not, so the user must set this flag to tell us. It will be</span>
<span class="sd">        ignored if the response doesn&#39;t look image-like or if the model has its</span>
<span class="sd">        own plot_representation_error() method. Else, it will be passed to</span>
<span class="sd">        `po.imshow()`, see that methods docstring for details.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Passed to ``metamer.model.forward``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    axes :</span>
<span class="sd">        List of created axes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">representation_error</span> <span class="o">=</span> <span class="n">_representation_error</span><span class="p">(</span><span class="n">metamer</span><span class="o">=</span><span class="n">metamer</span><span class="p">,</span>
                                                 <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">display</span><span class="o">.</span><span class="n">plot_representation</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">representation_error</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span>
                                       <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Representation error&quot;</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span>
                                       <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span> <span class="n">as_rgb</span><span class="o">=</span><span class="n">as_rgb</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_pixel_values">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.plot_pixel_values">[docs]</a>
<span class="k">def</span> <span class="nf">plot_pixel_values</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
                      <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="n">channel_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">ylim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Plot histogram of pixel values of target image and its metamer.</span>

<span class="sd">    As a way to check the distributions of pixel intensities and see</span>
<span class="sd">    if there&#39;s any values outside the allowed range</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object with the images whose pixel values we want to compare.</span>
<span class="sd">    batch_idx :</span>
<span class="sd">        Which index to take from the batch dimension</span>
<span class="sd">    channel_idx :</span>
<span class="sd">        Which index to take from the channel dimension. If None, we use all</span>
<span class="sd">        channels (assumed use-case is RGB(A) images).</span>
<span class="sd">    iteration :</span>
<span class="sd">        Which iteration to display. If None, the default, we show</span>
<span class="sd">        the most recent one. Negative values are also allowed.</span>
<span class="sd">    ylim :</span>
<span class="sd">        if tuple, the ylimit to set for this axis. If False, we leave</span>
<span class="sd">        it untouched</span>
<span class="sd">    ax :</span>
<span class="sd">        Pre-existing axes for plot. If None, we call ``plt.gca()``.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        passed to plt.hist</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax :</span>
<span class="sd">        Created axes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_freedman_diaconis_bins</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate number of hist bins using Freedman-Diaconis rule. copied from seaborn.&quot;&quot;&quot;</span>
        <span class="c1"># From https://stats.stackexchange.com/questions/798/</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">iqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mf">.25</span><span class="p">,</span> <span class="mf">.75</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iqr</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># fall back to sqrt(a) bins if iqr is 0</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">h</span><span class="p">))</span>

    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mf">.4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">met</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">metamer</span><span class="p">[</span><span class="n">batch_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">met</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="p">[</span><span class="n">iteration</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">]</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">metamer</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">batch_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">channel_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">met</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">met</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">met</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">_freedman_diaconis_bins</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="mi">50</span><span class="p">),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;metamer&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">_freedman_diaconis_bins</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="mi">50</span><span class="p">),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;target image&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ylim</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Histogram of pixel values&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span></div>



<span class="k">def</span> <span class="nf">_check_included_plots</span><span class="p">(</span><span class="n">to_check</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                          <span class="n">to_check_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check whether the user wanted us to create plots that we can&#39;t.</span>

<span class="sd">    Helper function for plot_synthesis_status and animate.</span>

<span class="sd">    Raises a ValueError to_check contains any values that are not allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    to_check :</span>
<span class="sd">        The variable to check. We ensure that it doesn&#39;t contain any extra (not</span>
<span class="sd">        allowed) values. If a list, we check its contents. If a dict, we check</span>
<span class="sd">        its keys.</span>
<span class="sd">    to_check_name :</span>
<span class="sd">        Name of the `to_check` variable, used in the error message.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">allowed_vals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">,</span> <span class="s1">&#39;plot_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;plot_representation_error&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;plot_pixel_values&#39;</span><span class="p">,</span> <span class="s1">&#39;misc&#39;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">to_check</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">to_check</span>
    <span class="n">not_allowed</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_vals</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">not_allowed</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_check_name</span><span class="si">}</span><span class="s1"> contained value(s) </span><span class="si">{</span><span class="n">not_allowed</span><span class="si">}</span><span class="s1">! &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;Only </span><span class="si">{</span><span class="n">allowed_vals</span><span class="si">}</span><span class="s1"> are permissible!&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_setup_synthesis_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">axes_idx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
                         <span class="n">figsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">included_plots</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">,</span>
                                                      <span class="s1">&#39;plot_loss&#39;</span><span class="p">,</span>
                                                      <span class="s1">&#39;plot_representation_error&#39;</span><span class="p">],</span>
                         <span class="n">display_metamer_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">plot_loss_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">plot_representation_error_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">plot_pixel_values_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set up figure for plot_synthesis_status.</span>

<span class="sd">    Creates figure with enough axes for the all the plots you want. Will</span>
<span class="sd">    also create index in axes_idx for them if you haven&#39;t done so already.</span>

<span class="sd">    By default, all axes will be on the same row and have the same width.</span>
<span class="sd">    If you want them to be on different rows, will need to initialize fig</span>
<span class="sd">    yourself and pass that in. For changing width, change the corresponding</span>
<span class="sd">    *_width arg, which gives width relative to other axes. So if you want</span>
<span class="sd">    the axis for the representation_error plot to be twice as wide as the</span>
<span class="sd">    others, set representation_error_width=2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fig :</span>
<span class="sd">        The figure to plot on or None. If None, we create a new figure</span>
<span class="sd">    axes_idx :</span>
<span class="sd">        Dictionary specifying which axes contains which type of plot, allows</span>
<span class="sd">        for more fine-grained control of the resulting figure. Probably only</span>
<span class="sd">        helpful if fig is also defined. Possible keys: loss, representation_error,</span>
<span class="sd">        pixel_values, misc. Values should all be ints. If you tell this</span>
<span class="sd">        function to create a plot that doesn&#39;t have a corresponding key, we</span>
<span class="sd">        find the lowest int that is not already in the dict, so if you have</span>
<span class="sd">        axes that you want unchanged, place their idx in misc.</span>
<span class="sd">    figsize :</span>
<span class="sd">        The size of the figure to create. It may take a little bit of</span>
<span class="sd">        playing around to find a reasonable value. If None, we attempt to</span>
<span class="sd">        make our best guess, aiming to have relative width=1 correspond to 5</span>
<span class="sd">    included_plots :</span>
<span class="sd">        Which plots to include. Must be some subset of ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;``.</span>
<span class="sd">    display_metamer_width :</span>
<span class="sd">        Relative width of the axis for the synthesized metamer.</span>
<span class="sd">    plot_loss_width :</span>
<span class="sd">        Relative width of the axis for loss plot.</span>
<span class="sd">    plot_representation_error_width :</span>
<span class="sd">        Relative width of the axis for representation error plot.</span>
<span class="sd">    plot_pixel_values_width :</span>
<span class="sd">        Relative width of the axis for image pixel intensities histograms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig :</span>
<span class="sd">        The figure to plot on</span>
<span class="sd">    axes :</span>
<span class="sd">        List or array of axes contained in fig</span>
<span class="sd">    axes_idx :</span>
<span class="sd">        Dictionary identifying the idx for each plot type</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_subplots</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">axes_idx</span> <span class="o">=</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">width_ratios</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="s2">&quot;display_metamer&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">n_subplots</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">width_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">display_metamer_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;display_metamer&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_find_min_int</span><span class="p">(</span><span class="n">axes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="s2">&quot;plot_loss&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">n_subplots</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">width_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_loss_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;plot_loss&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_loss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_find_min_int</span><span class="p">(</span><span class="n">axes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="s2">&quot;plot_representation_error&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">n_subplots</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">width_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_representation_error_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;plot_representation_error&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_representation_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_find_min_int</span><span class="p">(</span><span class="n">axes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="s2">&quot;plot_pixel_values&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">n_subplots</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">width_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_pixel_values_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;plot_pixel_values&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_pixel_values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_find_min_int</span><span class="p">(</span><span class="n">axes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">width_ratios</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">figsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we want (5, 5) for each subplot, with a bit of room between</span>
            <span class="c1"># each subplot</span>
            <span class="n">figsize</span> <span class="o">=</span> <span class="p">((</span><span class="n">width_ratios</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">width_ratios</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">width_ratios</span> <span class="o">=</span> <span class="n">width_ratios</span> <span class="o">/</span> <span class="n">width_ratios</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_subplots</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                                 <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;width_ratios&#39;</span><span class="p">:</span> <span class="n">width_ratios</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">n_subplots</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span>
    <span class="c1"># make sure misc contains all the empty axes</span>
    <span class="n">misc_axes</span> <span class="o">=</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;misc&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">misc_axes</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="n">misc_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">misc_axes</span><span class="p">]</span>
    <span class="n">all_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="c1"># so if it&#39;s a list of ints</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">all_axes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">misc_axes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_axes</span><span class="p">]</span>
    <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">misc_axes</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">axes_idx</span>


<div class="viewcode-block" id="plot_synthesis_status">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.plot_synthesis_status">[docs]</a>
<span class="k">def</span> <span class="nf">plot_synthesis_status</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
                          <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">channel_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">iteration</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">ylim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">vrange</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;indep1&#39;</span><span class="p">,</span>
                          <span class="n">zoom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">plot_representation_error_as_rgb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">fig</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">axes_idx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
                          <span class="n">figsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">included_plots</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;plot_loss&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;plot_representation_error&#39;</span><span class="p">],</span>
                          <span class="n">width_ratios</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make a plot showing synthesis status.</span>

<span class="sd">    We create several subplots to analyze this. By default, we create three</span>
<span class="sd">    subplots on a new figure: the first one contains the synthesized metamer,</span>
<span class="sd">    the second contains the loss, and the third contains the representation</span>
<span class="sd">    error.</span>

<span class="sd">    There is an optional additional plot: ``plot_pixel_values``, a histogram of</span>
<span class="sd">    pixel values of the metamer and target image.</span>

<span class="sd">    The plots to include are specified by including their name in the</span>
<span class="sd">    ``included_plots`` list. All plots can be created separately using the</span>
<span class="sd">    method with the same name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object whose status we want to plot.</span>
<span class="sd">    batch_idx :</span>
<span class="sd">        Which index to take from the batch dimension</span>
<span class="sd">    channel_idx :</span>
<span class="sd">        Which index to take from the channel dimension. If None, we use all</span>
<span class="sd">        channels (assumed use-case is RGB(A) image).</span>
<span class="sd">    iteration :</span>
<span class="sd">        Which iteration to display. If None, the default, we show</span>
<span class="sd">        the most recent one. Negative values are also allowed.</span>
<span class="sd">    ylim :</span>
<span class="sd">        The ylimit to use for the representation_error plot. We pass</span>
<span class="sd">        this value directly to ``plot_representation_error``</span>
<span class="sd">    vrange :</span>
<span class="sd">        The vrange option to pass to ``display_metamer()``. See</span>
<span class="sd">        docstring of ``imshow`` for possible values.</span>
<span class="sd">    zoom :</span>
<span class="sd">        How much to zoom in / enlarge the metamer, the ratio</span>
<span class="sd">        of display pixels to image pixels. If None (the default), we</span>
<span class="sd">        attempt to find the best value ourselves.</span>
<span class="sd">    plot_representation_error_as_rgb : bool, optional</span>
<span class="sd">        The representation can be image-like with multiple channels, and we</span>
<span class="sd">        have no way to determine whether it should be represented as an RGB</span>
<span class="sd">        image or not, so the user must set this flag to tell us. It will be</span>
<span class="sd">        ignored if the response doesn&#39;t look image-like or if the</span>
<span class="sd">        model has its own plot_representation_error() method. Else, it will</span>
<span class="sd">        be passed to `po.imshow()`, see that methods docstring for details.</span>
<span class="sd">    fig :</span>
<span class="sd">        if None, we create a new figure. otherwise we assume this is</span>
<span class="sd">        an empty figure that has the appropriate size and number of</span>
<span class="sd">        subplots</span>
<span class="sd">    axes_idx :</span>
<span class="sd">        Dictionary specifying which axes contains which type of plot, allows</span>
<span class="sd">        for more fine-grained control of the resulting figure. Probably only</span>
<span class="sd">        helpful if fig is also defined. Possible keys: ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;,</span>
<span class="sd">        &#39;misc&#39;``. Values should all be ints. If you tell this function to</span>
<span class="sd">        create a plot that doesn&#39;t have a corresponding key, we find the lowest</span>
<span class="sd">        int that is not already in the dict, so if you have axes that you want</span>
<span class="sd">        unchanged, place their idx in ``&#39;misc&#39;``.</span>
<span class="sd">    figsize :</span>
<span class="sd">        The size of the figure to create. It may take a little bit of</span>
<span class="sd">        playing around to find a reasonable value. If None, we attempt to</span>
<span class="sd">        make our best guess, aiming to have each axis be of size (5, 5)</span>
<span class="sd">    included_plots :</span>
<span class="sd">        Which plots to include. Must be some subset of ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;``.</span>
<span class="sd">    width_ratios :</span>
<span class="sd">        By default, all plots axes will have the same width. To change</span>
<span class="sd">        that, specify their relative widths using the keys: ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;`` and floats</span>
<span class="sd">        specifying their relative width. Any not included will be assumed to be</span>
<span class="sd">        1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig :</span>
<span class="sd">        The figure containing this plot</span>
<span class="sd">    axes_idx :</span>
<span class="sd">        Dictionary giving index of each plot.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">metamer</span><span class="o">.</span><span class="n">store_progress</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;synthesis() was run with store_progress=False, &quot;</span>
                         <span class="s2">&quot;cannot specify which iteration to plot (only&quot;</span>
                         <span class="s2">&quot; last one, with iteration=None)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metamer</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;plot_synthesis_status() expects 3 or 4d data;&quot;</span>
                         <span class="s2">&quot;unexpected behavior will result otherwise!&quot;</span><span class="p">)</span>
    <span class="n">_check_included_plots</span><span class="p">(</span><span class="n">included_plots</span><span class="p">,</span> <span class="s1">&#39;included_plots&#39;</span><span class="p">)</span>
    <span class="n">_check_included_plots</span><span class="p">(</span><span class="n">width_ratios</span><span class="p">,</span> <span class="s1">&#39;width_ratios&#39;</span><span class="p">)</span>
    <span class="n">_check_included_plots</span><span class="p">(</span><span class="n">axes_idx</span><span class="p">,</span> <span class="s1">&#39;axes_idx&#39;</span><span class="p">)</span>
    <span class="n">width_ratios</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">_width&#39;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">width_ratios</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">axes_idx</span> <span class="o">=</span> <span class="n">_setup_synthesis_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axes_idx</span><span class="p">,</span> <span class="n">figsize</span><span class="p">,</span>
                                               <span class="n">included_plots</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">width_ratios</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_iterables</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># then it&#39;s an iterable</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># then it&#39;s not an iterable</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="s2">&quot;display_metamer&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">display_metamer</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span> <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
                        <span class="n">channel_idx</span><span class="o">=</span><span class="n">channel_idx</span><span class="p">,</span>
                        <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span>
                        <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">]],</span>
                        <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">,</span> <span class="n">vrange</span><span class="o">=</span><span class="n">vrange</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;plot_loss&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">plot_loss</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_loss&#39;</span><span class="p">]])</span>
    <span class="k">if</span> <span class="s2">&quot;plot_representation_error&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">plot_representation_error</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span> <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
                                  <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span>
                                  <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_representation_error&#39;</span><span class="p">]],</span>
                                  <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span>
                                  <span class="n">as_rgb</span><span class="o">=</span><span class="n">plot_representation_error_as_rgb</span><span class="p">)</span>
        <span class="c1"># this can add a bunch of axes, so this will try and figure</span>
        <span class="c1"># them out</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span>
                    <span class="n">check_iterables</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axes_idx</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span> <span class="o">+</span> <span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_representation_error&#39;</span><span class="p">]]</span>
        <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_representation_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_axes</span>
    <span class="k">if</span> <span class="s2">&quot;plot_pixel_values&quot;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">plot_pixel_values</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span> <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
                          <span class="n">channel_idx</span><span class="o">=</span><span class="n">channel_idx</span><span class="p">,</span>
                          <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span>
                          <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_pixel_values&#39;</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes_idx</span></div>



<div class="viewcode-block" id="animate">
<a class="viewcode-back" href="../../../api/plenoptic.synthesize.html#plenoptic.synthesize.metamer.animate">[docs]</a>
<span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">metamer</span><span class="p">:</span> <span class="n">Metamer</span><span class="p">,</span>
            <span class="n">framerate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
            <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">channel_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">ylim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">vrange</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">zoom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">plot_representation_error_as_rgb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">fig</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">axes_idx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
            <span class="n">figsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">included_plots</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;plot_loss&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;plot_representation_error&#39;</span><span class="p">],</span>
            <span class="n">width_ratios</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpl</span><span class="o">.</span><span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Animate synthesis progress.</span>

<span class="sd">    This is essentially the figure produced by</span>
<span class="sd">    ``metamer.plot_synthesis_status`` animated over time, for each stored</span>
<span class="sd">    iteration.</span>

<span class="sd">    We return the matplotlib FuncAnimation object. In order to view it in a</span>
<span class="sd">    Jupyter notebook, use the</span>
<span class="sd">    ``plenoptic.tools.display.convert_anim_to_html(anim)`` function. In order</span>
<span class="sd">    to save, use ``anim.save(filename)`` (note for this that you&#39;ll need the</span>
<span class="sd">    appropriate writer installed and on your path, e.g., ffmpeg, imagemagick,</span>
<span class="sd">    etc). Either of these will probably take a reasonably long amount of time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metamer :</span>
<span class="sd">        Metamer object whose synthesis we want to animate.</span>
<span class="sd">    framerate :</span>
<span class="sd">        How many frames a second to display.</span>
<span class="sd">    batch_idx :</span>
<span class="sd">        Which index to take from the batch dimension</span>
<span class="sd">    channel_idx :</span>
<span class="sd">        Which index to take from the channel dimension. If None, we use all</span>
<span class="sd">        channels (assumed use-case is RGB(A) image).</span>
<span class="sd">    ylim :</span>
<span class="sd">        The y-limits of the representation_error plot:</span>

<span class="sd">        * If a tuple, then this is the ylim of all plots</span>

<span class="sd">        * If None, then all plots have the same limits, all</span>
<span class="sd">          symmetric about 0 with a limit of</span>
<span class="sd">          ``np.abs(representation_error).max()`` (for the initial</span>
<span class="sd">          representation_error)</span>

<span class="sd">        * If False, don&#39;t modify limits.</span>

<span class="sd">        * If a string, must be &#39;rescale&#39; or of the form &#39;rescaleN&#39;,</span>
<span class="sd">          where N can be any integer. If &#39;rescaleN&#39;, we rescale the</span>
<span class="sd">          limits every N frames (we rescale as if ylim = None). If</span>
<span class="sd">          &#39;rescale&#39;, then we do this 10 times over the course of the</span>
<span class="sd">          animation</span>

<span class="sd">    vrange :</span>
<span class="sd">        The vrange option to pass to ``display_metamer()``. See</span>
<span class="sd">        docstring of ``imshow`` for possible values.</span>
<span class="sd">    zoom :</span>
<span class="sd">        How much to zoom in / enlarge the metamer, the ratio</span>
<span class="sd">        of display pixels to image pixels. If None (the default), we</span>
<span class="sd">        attempt to find the best value ourselves.</span>
<span class="sd">    plot_representation_error_as_rgb :</span>
<span class="sd">        The representation can be image-like with multiple channels, and we</span>
<span class="sd">        have no way to determine whether it should be represented as an RGB</span>
<span class="sd">        image or not, so the user must set this flag to tell us. It will be</span>
<span class="sd">        ignored if the representation doesn&#39;t look image-like or if the</span>
<span class="sd">        model has its own plot_representation_error() method. Else, it will</span>
<span class="sd">        be passed to `po.imshow()`, see that methods docstring for details.</span>
<span class="sd">        since plot_synthesis_status normally sets it up for us</span>
<span class="sd">    fig :</span>
<span class="sd">        If None, create the figure from scratch. Else, should be an empty</span>
<span class="sd">        figure with enough axes (the expected use here is have same-size</span>
<span class="sd">        movies with different plots).</span>
<span class="sd">    axes_idx :</span>
<span class="sd">        Dictionary specifying which axes contains which type of plot, allows</span>
<span class="sd">        for more fine-grained control of the resulting figure. Probably only</span>
<span class="sd">        helpful if fig is also defined. Possible keys: ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;,</span>
<span class="sd">        &#39;misc&#39;``. Values should all be ints. If you tell this function to</span>
<span class="sd">        create a plot that doesn&#39;t have a corresponding key, we find the lowest</span>
<span class="sd">        int that is not already in the dict, so if you have axes that you want</span>
<span class="sd">        unchanged, place their idx in ``&#39;misc&#39;``.</span>
<span class="sd">    figsize :</span>
<span class="sd">        The size of the figure to create. It may take a little bit of</span>
<span class="sd">        playing around to find a reasonable value. If None, we attempt to</span>
<span class="sd">        make our best guess, aiming to have each axis be of size (5, 5)</span>
<span class="sd">    included_plots :</span>
<span class="sd">        Which plots to include. Must be some subset of ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;``.</span>
<span class="sd">    width_ratios :</span>
<span class="sd">        By default, all plots axes will have the same width. To change</span>
<span class="sd">        that, specify their relative widths using the keys: ``&#39;display_metamer&#39;,</span>
<span class="sd">        &#39;plot_loss&#39;, &#39;plot_representation_error&#39;, &#39;plot_pixel_values&#39;`` and floats</span>
<span class="sd">        specifying their relative width. Any not included will be assumed to be</span>
<span class="sd">        1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    anim :</span>
<span class="sd">        The animation object. In order to view, must convert to HTML</span>
<span class="sd">        or save.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, we use the ffmpeg backend, which requires that you have</span>
<span class="sd">    ffmpeg installed and on your path (https://ffmpeg.org/download.html).</span>
<span class="sd">    To use a different, use the matplotlib rcParams:</span>
<span class="sd">    `matplotlib.rcParams[&#39;animation.writer&#39;] = writer`, see</span>
<span class="sd">    https://matplotlib.org/stable/api/animation_api.html#writer-classes for</span>
<span class="sd">    more details.</span>

<span class="sd">    For displaying in a jupyter notebook, ffmpeg appears to be required.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metamer</span><span class="o">.</span><span class="n">store_progress</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;synthesize() was run with store_progress=False,&quot;</span>
                         <span class="s2">&quot; cannot animate!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metamer</span><span class="o">.</span><span class="n">metamer</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;animate() expects 3 or 4d data; unexpected&quot;</span>
                         <span class="s2">&quot; behavior will result otherwise!&quot;</span><span class="p">)</span>
    <span class="n">_check_included_plots</span><span class="p">(</span><span class="n">included_plots</span><span class="p">,</span> <span class="s1">&#39;included_plots&#39;</span><span class="p">)</span>
    <span class="n">_check_included_plots</span><span class="p">(</span><span class="n">width_ratios</span><span class="p">,</span> <span class="s1">&#39;width_ratios&#39;</span><span class="p">)</span>
    <span class="n">_check_included_plots</span><span class="p">(</span><span class="n">axes_idx</span><span class="p">,</span> <span class="s1">&#39;axes_idx&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metamer</span><span class="o">.</span><span class="n">target_representation</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># we have to do this here so that we set the</span>
        <span class="c1"># ylim_rescale_interval such that we never rescale ylim</span>
        <span class="c1"># (rescaling ylim messes up an image axis)</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ylim</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;rescale&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ylim_rescale_interval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ylim</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;rescale&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># then there&#39;s nothing we can convert to an int there</span>
                <span class="n">ylim_rescale_interval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ylim_rescale_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ylim_rescale_interval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to handle ylim </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="n">ylim</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># this way we&#39;ll never rescale</span>
        <span class="n">ylim_rescale_interval</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="c1"># we run plot_synthesis_status to initialize the figure if either fig is</span>
    <span class="c1"># None or if there are no titles on any axes, which we assume means that</span>
    <span class="c1"># it&#39;s an empty figure</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">get_title</span><span class="p">()</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">]):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes_idx</span> <span class="o">=</span> <span class="n">plot_synthesis_status</span><span class="p">(</span><span class="n">metamer</span><span class="o">=</span><span class="n">metamer</span><span class="p">,</span>
                                              <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
                                              <span class="n">channel_idx</span><span class="o">=</span><span class="n">channel_idx</span><span class="p">,</span>
                                              <span class="n">iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                                              <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="n">vrange</span><span class="o">=</span><span class="n">vrange</span><span class="p">,</span>
                                              <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                              <span class="n">axes_idx</span><span class="o">=</span><span class="n">axes_idx</span><span class="p">,</span>
                                              <span class="n">included_plots</span><span class="o">=</span><span class="n">included_plots</span><span class="p">,</span>
                                              <span class="n">plot_representation_error_as_rgb</span><span class="o">=</span><span class="n">plot_representation_error_as_rgb</span><span class="p">,</span>
                                              <span class="n">width_ratios</span><span class="o">=</span><span class="n">width_ratios</span><span class="p">)</span>
    <span class="c1"># grab the artist for the second plot (we don&#39;t need to do this for the</span>
    <span class="c1"># metamer or representation plot, because we use the update_plot</span>
    <span class="c1"># function for that)</span>
    <span class="k">if</span> <span class="s1">&#39;plot_loss&#39;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="n">scat</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_loss&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># can have multiple plots</span>
    <span class="k">if</span> <span class="s1">&#39;plot_representation_error&#39;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rep_error_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_representation_error&#39;</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># in this case, axes_idx[&#39;plot_representation_error&#39;] is not iterable and so is</span>
            <span class="c1"># a single value</span>
            <span class="n">rep_error_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_representation_error&#39;</span><span class="p">]]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rep_error_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># can also have multiple plots</span>

    <span class="k">if</span> <span class="n">metamer</span><span class="o">.</span><span class="n">target_representation</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;plot_representation_error&#39;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Looks like representation is image-like, haven&#39;t fully thought out how&quot;</span>
                          <span class="s2">&quot; to best handle rescaling color ranges yet!&quot;</span><span class="p">)</span>
        <span class="c1"># replace the bit of the title that specifies the range,</span>
        <span class="c1"># since we don&#39;t make any promises about that. we have to do</span>
        <span class="c1"># this here because we need the figure to have been created</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">rep_error_axes</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\n range: .* \n&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_title</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">movie_plot</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;display_metamer&#39;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
            <span class="n">artists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">update_plot</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;display_metamer&#39;</span><span class="p">]],</span>
                                               <span class="n">data</span><span class="o">=</span><span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                               <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;plot_representation_error&#39;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
            <span class="n">rep_error</span> <span class="o">=</span> <span class="n">_representation_error</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span>
                                                     <span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># we pass rep_error_axes to update, and we&#39;ve grabbed</span>
            <span class="c1"># the right things above</span>
            <span class="n">artists</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">update_plot</span><span class="p">(</span><span class="n">rep_error_axes</span><span class="p">,</span>
                                               <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
                                               <span class="n">model</span><span class="o">=</span><span class="n">metamer</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                               <span class="n">data</span><span class="o">=</span><span class="n">rep_error</span><span class="p">))</span>
            <span class="c1"># again, we know that rep_error_axes contains all the axes</span>
            <span class="c1"># with the representation ratio info</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ylim_rescale_interval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metamer</span><span class="o">.</span><span class="n">target_representation</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">display</span><span class="o">.</span><span class="n">rescale_ylim</span><span class="p">(</span><span class="n">rep_error_axes</span><span class="p">,</span>
                                         <span class="n">rep_error</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;plot_pixel_values&#39;</span> <span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
            <span class="c1"># this is the dumbest way to do this, but it&#39;s simple --</span>
            <span class="c1"># clearing the axes can cause problems if the user has, for</span>
            <span class="c1"># example, changed the tick locator or formatter. not sure how</span>
            <span class="c1"># to handle this best right now</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_pixel_values&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">plot_pixel_values</span><span class="p">(</span><span class="n">metamer</span><span class="p">,</span> <span class="n">batch_idx</span><span class="o">=</span><span class="n">batch_idx</span><span class="p">,</span>
                              <span class="n">channel_idx</span><span class="o">=</span><span class="n">channel_idx</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                              <span class="n">ax</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes_idx</span><span class="p">[</span><span class="s1">&#39;plot_pixel_values&#39;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="s1">&#39;plot_loss&#39;</span><span class="ow">in</span> <span class="n">included_plots</span><span class="p">:</span>
            <span class="c1"># loss always contains values from every iteration, but everything</span>
            <span class="c1"># else will be subsampled.</span>
            <span class="n">x_val</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">metamer</span><span class="o">.</span><span class="n">store_progress</span>
            <span class="n">scat</span><span class="o">.</span><span class="n">set_offsets</span><span class="p">((</span><span class="n">x_val</span><span class="p">,</span> <span class="n">metamer</span><span class="o">.</span><span class="n">losses</span><span class="p">[</span><span class="n">x_val</span><span class="p">]))</span>
            <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scat</span><span class="p">)</span>
        <span class="c1"># as long as blitting is True, need to return a sequence of artists</span>
        <span class="k">return</span> <span class="n">artists</span>

    <span class="c1"># don&#39;t need an init_func, since we handle initialization ourselves</span>
    <span class="n">anim</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">movie_plot</span><span class="p">,</span>
                                       <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">metamer</span><span class="o">.</span><span class="n">saved_metamer</span><span class="p">),</span>
                                       <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">1000.</span><span class="o">/</span><span class="n">framerate</span><span class="p">,</span>
                                       <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">anim</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Lab for Computational Vision.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>