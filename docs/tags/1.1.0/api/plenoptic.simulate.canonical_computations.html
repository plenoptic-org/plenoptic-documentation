

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>plenoptic.simulate.canonical_computations package &mdash; plenoptic 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=4c969af8" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=fc837d61"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/tabs.js?v=3ee01567"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="plenoptic.simulate.models package" href="plenoptic.simulate.models.html" />
    <link rel="prev" title="plenoptic.simulate package" href="plenoptic.simulate.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            plenoptic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conceptual_intro.html">Conceptual Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models.html">Model requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/00_quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citation.html">Citation Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Synthesis method introductions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/intro/02_Eigendistortions.html">Eigendistortions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/intro/06_Metamer.html">Metamers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/intro/07_Simple_MAD.html">MAD Competition Conceptual Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/intro/08_MAD_Competition.html">MAD Competition Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Models and metrics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/models/03_Steerable_Pyramid.html">Steerable Pyramid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/models/04_Perceptual_distance.html">Perceptual distance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/models/Metamer-Portilla-Simoncelli.html">Portilla-Simoncelli Texture Metamer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Synthesis method examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/applications/09_Original_MAD.html">Reproducing Wang and Simoncelli, 2008 (MAD Competition)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/applications/Demo_Eigendistortion.html">Reproducing Berardino et al., 2017 (Eigendistortions)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../synthesis.html">Synthesis object design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tips.html">Tips and Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reproducibility.html">Reproducibility</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="plenoptic.html">plenoptic package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="plenoptic.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="plenoptic.data.html">plenoptic.data package</a></li>
<li class="toctree-l4"><a class="reference internal" href="plenoptic.metric.html">plenoptic.metric package</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="plenoptic.simulate.html">plenoptic.simulate package</a></li>
<li class="toctree-l4"><a class="reference internal" href="plenoptic.synthesize.html">plenoptic.synthesize package</a></li>
<li class="toctree-l4"><a class="reference internal" href="plenoptic.tools.html">plenoptic.tools package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="plenoptic.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="plenoptic.html#module-plenoptic.version">plenoptic.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="plenoptic.html#module-plenoptic">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/advanced/Display.html">Display and animate functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/advanced/Synthesis_extensions.html">Extending existing synthesis objects</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">plenoptic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">plenoptic</a></li>
          <li class="breadcrumb-item"><a href="plenoptic.html">plenoptic package</a></li>
          <li class="breadcrumb-item"><a href="plenoptic.simulate.html">plenoptic.simulate package</a></li>
      <li class="breadcrumb-item active">plenoptic.simulate.canonical_computations package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/plenoptic.simulate.canonical_computations.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="plenoptic-simulate-canonical-computations-package">
<h1>plenoptic.simulate.canonical_computations package<a class="headerlink" href="#plenoptic-simulate-canonical-computations-package" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-plenoptic.simulate.canonical_computations.filters">
<span id="plenoptic-simulate-canonical-computations-filters-module"></span><h2>plenoptic.simulate.canonical_computations.filters module<a class="headerlink" href="#module-plenoptic.simulate.canonical_computations.filters" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.filters.circular_gaussian2d">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.filters.</span></span><span class="sig-name descname"><span class="pre">circular_gaussian2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/filters.html#circular_gaussian2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.filters.circular_gaussian2d" title="Link to this definition"></a></dt>
<dd><p>Creates normalized, centered circular 2D gaussian tensor with which to convolve.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel_size</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – Filter kernel size. Recommended to be odd so that kernel is properly centered.</p></li>
<li><p><strong>std</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]</span>) – Standard deviation of 2D circular Gaussian.</p></li>
<li><p><strong>out_channels</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – Number of channels with same kernel repeated along channel dim.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Circular gaussian kernel, normalized by total pixel-sum (_not_ by 2pi*std).
<cite>filt</cite> has <cite>Size([out_channels=n_channels, in_channels=1, height, width])</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>filt</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.filters.gaussian1d">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.filters.</span></span><span class="sig-name descname"><span class="pre">gaussian1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/filters.html#gaussian1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.filters.gaussian1d" title="Link to this definition"></a></dt>
<dd><p>Normalized 1D Gaussian.</p>
<p>1d Gaussian of size <cite>kernel_size</cite>, centered half-way, with variable std
deviation, and sum of 1.</p>
<p>With default values, this is the 1d Gaussian used to generate the windows
for SSIM</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel_size</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – Size of Gaussian. Recommended to be odd so that kernel is properly centered.</p></li>
<li><p><strong>std</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]</span>) – Standard deviation of Gaussian.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>1d Gaussian with <cite>Size([kernel_size])</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>filt</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-plenoptic.simulate.canonical_computations.laplacian_pyramid">
<span id="plenoptic-simulate-canonical-computations-laplacian-pyramid-module"></span><h2>plenoptic.simulate.canonical_computations.laplacian_pyramid module<a class="headerlink" href="#module-plenoptic.simulate.canonical_computations.laplacian_pyramid" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.laplacian_pyramid.</span></span><span class="sig-name descname"><span class="pre">LaplacianPyramid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_scales</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/laplacian_pyramid.html#LaplacianPyramid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Laplacian Pyramid in Torch.</p>
<p>The Laplacian pyramid <a class="reference internal" href="#r26b8b7689908-1" id="id1">[1]</a> is a multiscale image representation. It
decomposes the image by computing the local mean using Gaussian blurring
filters and substracting it from the image and repeating this operation on
the local mean itself after downsampling. This representation is
overcomplete and invertible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_scales</strong> (<em>int</em>) – number of scales to compute</p></li>
<li><p><strong>scale_filter</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the norm of the downsampling/upsampling filter is 1. If false (default), it is 2.
If the norm is 1, the image is multiplied by 4 during the upsampling operation; the net effect
is that the <cite>n`th scale of the pyramid is divided by `2^n</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r26b8b7689908-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Burt, P. and Adelson, E., 1983. The Laplacian pyramid as a compact
image code. IEEE Transactions on communications, 31(4), pp.532-540.</p>
</div>
</div>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_module</span></code>(name, module)</p></td>
<td><p>Add a child module to the current module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code>(fn)</p></td>
<td><p>Apply <code class="docutils literal notranslate"><span class="pre">fn</span></code> recursively to every submodule (as returned by <code class="docutils literal notranslate"><span class="pre">.children()</span></code>) as well as self.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfloat16</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">bfloat16</span></code> datatype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">buffers</span></code>([recurse])</p></td>
<td><p>Return an iterator over module buffers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">children</span></code>()</p></td>
<td><p>Return an iterator over immediate children modules.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compile</span></code>(*args, **kwargs)</p></td>
<td><p>Compile this Module's forward using <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.compile()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cpu</span></code>()</p></td>
<td><p>Move all model parameters and buffers to the CPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cuda</span></code>([device])</p></td>
<td><p>Move all model parameters and buffers to the GPU.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">double</span></code> datatype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>()</p></td>
<td><p>Set the module in evaluation mode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extra_repr</span></code>()</p></td>
<td><p>Set the extra representation of the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">float</span></code> datatype.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.forward" title="plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward</span></code></a>(x)</p></td>
<td><p>Build the Laplacian pyramid of an image.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_buffer</span></code>(target)</p></td>
<td><p>Return the buffer given by <code class="docutils literal notranslate"><span class="pre">target</span></code> if it exists, otherwise throw an error.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_extra_state</span></code>()</p></td>
<td><p>Return any extra state to include in the module's state_dict.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_parameter</span></code>(target)</p></td>
<td><p>Return the parameter given by <code class="docutils literal notranslate"><span class="pre">target</span></code> if it exists, otherwise throw an error.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_submodule</span></code>(target)</p></td>
<td><p>Return the submodule given by <code class="docutils literal notranslate"><span class="pre">target</span></code> if it exists, otherwise throw an error.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">half</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">half</span></code> datatype.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ipu</span></code>([device])</p></td>
<td><p>Move all model parameters and buffers to the IPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_state_dict</span></code>(state_dict[, strict, assign])</p></td>
<td><p>Copy parameters and buffers from <code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code> into this module and its descendants.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">modules</span></code>()</p></td>
<td><p>Return an iterator over all modules in the network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_buffers</span></code>([prefix, recurse, ...])</p></td>
<td><p>Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_children</span></code>()</p></td>
<td><p>Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_modules</span></code>([memo, prefix, remove_duplicate])</p></td>
<td><p>Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_parameters</span></code>([prefix, recurse, ...])</p></td>
<td><p>Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameters</span></code>([recurse])</p></td>
<td><p>Return an iterator over module parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.recon_pyr" title="plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.recon_pyr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recon_pyr</span></code></a>(y)</p></td>
<td><p>Reconstruct the image from its Laplacian pyramid.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_backward_hook</span></code>(hook)</p></td>
<td><p>Register a backward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_buffer</span></code>(name, tensor[, persistent])</p></td>
<td><p>Add a buffer to the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_hook</span></code>(hook, *[, prepend, ...])</p></td>
<td><p>Register a forward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_pre_hook</span></code>(hook, *[, ...])</p></td>
<td><p>Register a forward pre-hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_full_backward_hook</span></code>(hook[, prepend])</p></td>
<td><p>Register a backward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_full_backward_pre_hook</span></code>(hook[, prepend])</p></td>
<td><p>Register a backward pre-hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_load_state_dict_post_hook</span></code>(hook)</p></td>
<td><p>Register a post hook to be run after module's <code class="docutils literal notranslate"><span class="pre">load_state_dict</span></code> is called.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_module</span></code>(name, module)</p></td>
<td><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">add_module()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_parameter</span></code>(name, param)</p></td>
<td><p>Add a parameter to the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_state_dict_pre_hook</span></code>(hook)</p></td>
<td><p>Register a pre-hook for the <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_state_dict()</span></code> method.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">requires_grad_</span></code>([requires_grad])</p></td>
<td><p>Change if autograd should record operations on parameters in this module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_extra_state</span></code>(state)</p></td>
<td><p>Set extra state contained in the loaded <cite>state_dict</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">share_memory</span></code>()</p></td>
<td><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.share_memory_()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_dict</span></code>(*args[, destination, prefix, ...])</p></td>
<td><p>Return a dictionary containing references to the whole state of the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to</span></code>(*args, **kwargs)</p></td>
<td><p>Move and/or cast the parameters and buffers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_empty</span></code>(*, device[, recurse])</p></td>
<td><p>Move the parameters and buffers to the specified device without copying storage.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">train</span></code>([mode])</p></td>
<td><p>Set the module in training mode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code>(dst_type)</p></td>
<td><p>Casts all parameters and buffers to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dst_type</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">xpu</span></code>([device])</p></td>
<td><p>Move all model parameters and buffers to the XPU.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zero_grad</span></code>([set_to_none])</p></td>
<td><p>Reset gradients of all model parameters.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>__call__</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/laplacian_pyramid.html#LaplacianPyramid.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.forward" title="Link to this definition"></a></dt>
<dd><p>Build the Laplacian pyramid of an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em><em> of </em><em>shape</em><em> (</em><em>batch</em><em>, </em><em>channel</em><em>, </em><em>height</em><em>, </em><em>width</em><em>)</em>) – Image, or batch of images. If there are multiple channels,
the Laplacian is computed separately for each of them</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y</strong> – Laplacian pyramid representation, each element of the list
corresponds to a scale, from fine to coarse</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.recon_pyr">
<span class="sig-name descname"><span class="pre">recon_pyr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/laplacian_pyramid.html#LaplacianPyramid.recon_pyr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.laplacian_pyramid.LaplacianPyramid.recon_pyr" title="Link to this definition"></a></dt>
<dd><p>Reconstruct the image from its Laplacian pyramid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>y</strong> (<em>list</em><em> of </em><em>torch.Tensor</em>) – Laplacian pyramid representation, each element of the list
corresponds to a scale, from fine to coarse</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x</strong> – Image, or batch of images</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor of shape (batch, channel, height, width)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-plenoptic.simulate.canonical_computations.non_linearities">
<span id="plenoptic-simulate-canonical-computations-non-linearities-module"></span><h2>plenoptic.simulate.canonical_computations.non_linearities module<a class="headerlink" href="#module-plenoptic.simulate.canonical_computations.non_linearities" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.non_linearities.local_gain_control">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.non_linearities.</span></span><span class="sig-name descname"><span class="pre">local_gain_control</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/non_linearities.html#local_gain_control"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.non_linearities.local_gain_control" title="Link to this definition"></a></dt>
<dd><p>Spatially local gain control.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>torch.Tensor</em>) – Tensor of shape (batch, channel, height, width)</p></li>
<li><p><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em>) – Small constant to avoid division by zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>norm</strong> (<em>torch.Tensor</em>) – The local energy of <code class="docutils literal notranslate"><span class="pre">x</span></code>. Note that it is down sampled by a
factor 2 in (unlike rect2pol).</p></li>
<li><p><strong>direction</strong> (<em>torch.Tensor</em>) – The local phase of <code class="docutils literal notranslate"><span class="pre">x</span></code> (aka. local unit vector, or local
state)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is an analogue to rectangular_to_polar for
real valued signals.</p>
<p>Norm and direction (analogous to complex modulus and phase) are
defined using blurring operator and division.  Indeed blurring the
responses removes high frequencies introduced by the squaring
operation. In the complex case adding the quadrature pair response
has the same effect (note that this is most clearly seen in the
frequency domain).  Here computing the direction (phase) reduces to
dividing out the norm (modulus), indeed the signal only has one real
component. This is a normalization operation (local unit vector),
hence the connection to local gain control.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.non_linearities.local_gain_control_dict">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.non_linearities.</span></span><span class="sig-name descname"><span class="pre">local_gain_control_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residuals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/non_linearities.html#local_gain_control_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.non_linearities.local_gain_control_dict" title="Link to this definition"></a></dt>
<dd><p>Spatially local gain control, for each element in a dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff_dict</strong> (<em>dict</em>) – A dictionary containing tensors of shape (batch, channel, height, width)</p></li>
<li><p><strong>residuals</strong> (<em>bool</em><em>, </em><em>optional</em>) – An option to carry around residuals in the energy dict.
Note that the transformation is not applied to the residuals,
that is dictionary elements with a key starting in “residual”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energy</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local energy of
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>state</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local phase of
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that energy and state is not computed on the residuals.</p>
<p>The inverse operation is achieved by <cite>local_gain_release_dict</cite>.
This function is an analogue to rectangular_to_polar_dict for real
valued signals. For more details, see <a class="reference internal" href="#plenoptic.simulate.canonical_computations.non_linearities.local_gain_control" title="plenoptic.simulate.canonical_computations.non_linearities.local_gain_control"><code class="xref py py-meth docutils literal notranslate"><span class="pre">local_gain_control()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.non_linearities.local_gain_release">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.non_linearities.</span></span><span class="sig-name descname"><span class="pre">local_gain_release</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/non_linearities.html#local_gain_release"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.non_linearities.local_gain_release" title="Link to this definition"></a></dt>
<dd><p>Spatially local gain release.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norm</strong> (<em>torch.Tensor</em>) – The local energy of <code class="docutils literal notranslate"><span class="pre">x</span></code>. Note that it is down sampled by a
factor 2 in (unlike rect2pol).</p></li>
<li><p><strong>direction</strong> (<em>torch.Tensor</em>) – The local phase of <code class="docutils literal notranslate"><span class="pre">x</span></code> (aka. local unit vector, or local
state)</p></li>
<li><p><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em>) – Small constant to avoid division by zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x</strong> – Tensor of shape (batch, channel, height, width)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is an analogue to polar_to_rectangular for
real valued signals.</p>
<p>Norm and direction (analogous to complex modulus and phase) are
defined using blurring operator and division.  Indeed blurring the
responses removes high frequencies introduced by the squaring
operation. In the complex case adding the quadrature pair response
has the same effect (note that this is most clearly seen in the
frequency domain).  Here computing the direction (phase) reduces to
dividing out the norm (modulus), indeed the signal only has one real
component. This is a normalization operation (local unit vector),
hence the connection to local gain control.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.non_linearities.local_gain_release_dict">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.non_linearities.</span></span><span class="sig-name descname"><span class="pre">local_gain_release_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residuals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/non_linearities.html#local_gain_release_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.non_linearities.local_gain_release_dict" title="Link to this definition"></a></dt>
<dd><p>Spatially local gain release, for each element in a dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>energy</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local energy of
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>state</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local phase of
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>residuals</strong> (<em>bool</em><em>, </em><em>optional</em>) – An option to carry around residuals in the energy dict.
Note that the transformation is not applied to the residuals,
that is dictionary elements with a key starting in “residual”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>coeff_dict</strong> – A dictionary containing tensors of shape (batch, channel, height, width)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The inverse operation to <cite>local_gain_control_dict</cite>.
This function is  an analogue to polar_to_rectangular_dict for real
valued signals. For more details, see <a class="reference internal" href="#plenoptic.simulate.canonical_computations.non_linearities.local_gain_release" title="plenoptic.simulate.canonical_computations.non_linearities.local_gain_release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">local_gain_release()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.non_linearities.polar_to_rectangular_dict">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.non_linearities.</span></span><span class="sig-name descname"><span class="pre">polar_to_rectangular_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residuals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/non_linearities.html#polar_to_rectangular_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.non_linearities.polar_to_rectangular_dict" title="Link to this definition"></a></dt>
<dd><p>Return the real and imaginary parts of tensor in a dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>energy</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local complex
modulus.</p></li>
<li><p><strong>state</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local phase.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em>) – The dimension that contains the real and imaginary components.</p></li>
<li><p><strong>residuals</strong> (<em>bool</em><em>, </em><em>optional</em>) – An option to carry around residuals in the energy branch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>coeff_dict</strong> – A dictionary containing complex tensors of coefficients.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.non_linearities.rectangular_to_polar_dict">
<span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.non_linearities.</span></span><span class="sig-name descname"><span class="pre">rectangular_to_polar_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residuals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/non_linearities.html#rectangular_to_polar_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.non_linearities.rectangular_to_polar_dict" title="Link to this definition"></a></dt>
<dd><p>Return the complex modulus and the phase of each complex tensor in a dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff_dict</strong> (<em>dict</em>) – A dictionary containing complex tensors.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em>) – The dimension that contains the real and imaginary components.</p></li>
<li><p><strong>residuals</strong> (<em>bool</em><em>, </em><em>optional</em>) – An option to carry around residuals in the energy branch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energy</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local complex
modulus of <code class="docutils literal notranslate"><span class="pre">coeff_dict</span></code>.</p></li>
<li><p><strong>state</strong> (<em>dict</em>) – The dictionary of torch.Tensors containing the local phase of
<code class="docutils literal notranslate"><span class="pre">coeff_dict</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-plenoptic.simulate.canonical_computations.steerable_pyramid_freq">
<span id="plenoptic-simulate-canonical-computations-steerable-pyramid-freq-module"></span><h2>plenoptic.simulate.canonical_computations.steerable_pyramid_freq module<a class="headerlink" href="#module-plenoptic.simulate.canonical_computations.steerable_pyramid_freq" title="Link to this heading"></a></h2>
<p>Steerable frequency pyramid</p>
<p>Construct a steerable pyramid on matrix two dimensional signals, in the
Fourier domain.</p>
<dl class="py class">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">plenoptic.simulate.canonical_computations.steerable_pyramid_freq.</span></span><span class="sig-name descname"><span class="pre">SteerablePyramidFreq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">twidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tight_frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/steerable_pyramid_freq.html#SteerablePyramidFreq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Steerable frequency pyramid in Torch</p>
<p>Construct a steerable pyramid on matrix two dimensional signals, in the
Fourier domain. Boundary-handling is circular. Reconstruction is exact
(within floating point errors). However, if the image has an odd-shape,
the reconstruction will not be exact due to boundary-handling issues
that have not been resolved.</p>
<p>The squared radial functions tile the Fourier plane with a raised-cosine
falloff. Angular functions are cos(theta-k*pi/order+1)^(order).</p>
<p class="rubric">Notes</p>
<p>Transform described in <a class="reference internal" href="#r19dab1595aee-1" id="id2">[1]</a>, filter kernel design described in <a class="reference internal" href="#r19dab1595aee-2" id="id3">[2]</a>.
For further information see the project <a href="#id4"><span class="problematic" id="id5">webpage_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_shape</strong> (<cite>list or tuple</cite>) – shape of input image</p></li>
<li><p><strong>height</strong> (‘auto’ or <cite>int</cite>) – The height of the pyramid. If ‘auto’, will automatically determine
based on the size of <cite>image</cite>.</p></li>
<li><p><strong>order</strong> (<cite>int</cite>.) – The Gaussian derivative order used for the steerable filters, in [1,
15]. Note that to achieve steerability the minimum number of
orientation is <cite>order</cite> + 1, and is used here. To get more orientations
at the same order, use the method <cite>steer_coeffs</cite></p></li>
<li><p><strong>twidth</strong> (<cite>int</cite>) – The width of the transition region of the radial lowpass function, in
octaves</p></li>
<li><p><strong>is_complex</strong> (<cite>bool</cite>) – Whether the pyramid coefficients should be complex or not. If True, the
real and imaginary parts correspond to a pair of even and odd symmetric
filters. If False, the coefficients only include the real part / even</p></li>
<li><p><strong>downsample</strong> (<cite>bool</cite>) – Whether to downsample each scale in the pyramid or keep the output
pyramid coefficients in fixed bands of size imshapeximshape. When
downsample is False, the forward method returns a tensor.</p></li>
<li><p><strong>tight_frame</strong> (<cite>bool</cite> default: False) – Whether the pyramid obeys the generalized parseval theorem or not (i.e.
is a tight frame). If True, the energy of the pyr_coeffs = energy of
the image. If not this is not true. In order to match the
matlabPyrTools or pyrtools pyramids, this must be set to False</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.image_shape">
<span class="sig-name descname"><span class="pre">image_shape</span></span><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.image_shape" title="Link to this definition"></a></dt>
<dd><p>shape of input image</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>list or tuple</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.pyr_size">
<span class="sig-name descname"><span class="pre">pyr_size</span></span><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.pyr_size" title="Link to this definition"></a></dt>
<dd><p>Dictionary containing the sizes of the pyramid coefficients. Keys are
<cite>(level, band)</cite> tuples and values are tuples.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.fft_norm">
<span class="sig-name descname"><span class="pre">fft_norm</span></span><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.fft_norm" title="Link to this definition"></a></dt>
<dd><p>The way the ffts are normalized, see pytorch documentation for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>str</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.is_complex">
<span class="sig-name descname"><span class="pre">is_complex</span></span><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.is_complex" title="Link to this definition"></a></dt>
<dd><p>Whether the coefficients are complex- or real-valued.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r19dab1595aee-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>E P Simoncelli and W T Freeman, “The Steerable Pyramid: A Flexible
Architecture for Multi-Scale Derivative Computation,” Second Int’l Conf
on Image Processing, Washington, DC, Oct 1995.</p>
</div>
<div class="citation" id="r19dab1595aee-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>A Karasaridis and E P Simoncelli, “A Filter Design Technique for
Steerable Pyramid Image Transforms”, ICASSP, Atlanta, GA, May 1996. ..
_webpage: <a class="reference external" href="https://www.cns.nyu.edu/~eero/steerpyr/">https://www.cns.nyu.edu/~eero/steerpyr/</a></p>
</div>
</div>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_module</span></code>(name, module)</p></td>
<td><p>Add a child module to the current module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code>(fn)</p></td>
<td><p>Apply <code class="docutils literal notranslate"><span class="pre">fn</span></code> recursively to every submodule (as returned by <code class="docutils literal notranslate"><span class="pre">.children()</span></code>) as well as self.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfloat16</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">bfloat16</span></code> datatype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">buffers</span></code>([recurse])</p></td>
<td><p>Return an iterator over module buffers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">children</span></code>()</p></td>
<td><p>Return an iterator over immediate children modules.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compile</span></code>(*args, **kwargs)</p></td>
<td><p>Compile this Module's forward using <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.compile()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_pyr_to_tensor" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_pyr_to_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_pyr_to_tensor</span></code></a>(pyr_coeffs[, ...])</p></td>
<td><p>Convert coefficient dictionary to a tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_tensor_to_pyr" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_tensor_to_pyr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_tensor_to_pyr</span></code></a>(pyr_tensor, ...)</p></td>
<td><p>Convert pyramid coefficient tensor to dictionary format.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cpu</span></code>()</p></td>
<td><p>Move all model parameters and buffers to the CPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cuda</span></code>([device])</p></td>
<td><p>Move all model parameters and buffers to the GPU.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">double</span></code> datatype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>()</p></td>
<td><p>Set the module in evaluation mode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extra_repr</span></code>()</p></td>
<td><p>Set the extra representation of the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">float</span></code> datatype.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.forward" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward</span></code></a>(x[, scales])</p></td>
<td><p>Generate the steerable pyramid coefficients for an image</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_buffer</span></code>(target)</p></td>
<td><p>Return the buffer given by <code class="docutils literal notranslate"><span class="pre">target</span></code> if it exists, otherwise throw an error.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_extra_state</span></code>()</p></td>
<td><p>Return any extra state to include in the module's state_dict.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_parameter</span></code>(target)</p></td>
<td><p>Return the parameter given by <code class="docutils literal notranslate"><span class="pre">target</span></code> if it exists, otherwise throw an error.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_submodule</span></code>(target)</p></td>
<td><p>Return the submodule given by <code class="docutils literal notranslate"><span class="pre">target</span></code> if it exists, otherwise throw an error.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">half</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">half</span></code> datatype.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ipu</span></code>([device])</p></td>
<td><p>Move all model parameters and buffers to the IPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_state_dict</span></code>(state_dict[, strict, assign])</p></td>
<td><p>Copy parameters and buffers from <code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code> into this module and its descendants.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">modules</span></code>()</p></td>
<td><p>Return an iterator over all modules in the network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_buffers</span></code>([prefix, recurse, ...])</p></td>
<td><p>Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_children</span></code>()</p></td>
<td><p>Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_modules</span></code>([memo, prefix, remove_duplicate])</p></td>
<td><p>Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_parameters</span></code>([prefix, recurse, ...])</p></td>
<td><p>Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameters</span></code>([recurse])</p></td>
<td><p>Return an iterator over module parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.recon_pyr" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.recon_pyr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recon_pyr</span></code></a>(pyr_coeffs[, levels, bands])</p></td>
<td><p>Reconstruct the image or batch of images, optionally using subset of pyramid coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_backward_hook</span></code>(hook)</p></td>
<td><p>Register a backward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_buffer</span></code>(name, tensor[, persistent])</p></td>
<td><p>Add a buffer to the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_hook</span></code>(hook, *[, prepend, ...])</p></td>
<td><p>Register a forward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_pre_hook</span></code>(hook, *[, ...])</p></td>
<td><p>Register a forward pre-hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_full_backward_hook</span></code>(hook[, prepend])</p></td>
<td><p>Register a backward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_full_backward_pre_hook</span></code>(hook[, prepend])</p></td>
<td><p>Register a backward pre-hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_load_state_dict_post_hook</span></code>(hook)</p></td>
<td><p>Register a post hook to be run after module's <code class="docutils literal notranslate"><span class="pre">load_state_dict</span></code> is called.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_module</span></code>(name, module)</p></td>
<td><p>Alias for <code class="xref py py-func docutils literal notranslate"><span class="pre">add_module()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_parameter</span></code>(name, param)</p></td>
<td><p>Add a parameter to the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_state_dict_pre_hook</span></code>(hook)</p></td>
<td><p>Register a pre-hook for the <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_state_dict()</span></code> method.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">requires_grad_</span></code>([requires_grad])</p></td>
<td><p>Change if autograd should record operations on parameters in this module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_extra_state</span></code>(state)</p></td>
<td><p>Set extra state contained in the loaded <cite>state_dict</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">share_memory</span></code>()</p></td>
<td><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.share_memory_()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_dict</span></code>(*args[, destination, prefix, ...])</p></td>
<td><p>Return a dictionary containing references to the whole state of the module.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.steer_coeffs" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.steer_coeffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">steer_coeffs</span></code></a>(pyr_coeffs, angles[, even_phase])</p></td>
<td><p>Steer pyramid coefficients to the specified angles</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to</span></code>(*args, **kwargs)</p></td>
<td><p>Move and/or cast the parameters and buffers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_empty</span></code>(*, device[, recurse])</p></td>
<td><p>Move the parameters and buffers to the specified device without copying storage.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">train</span></code>([mode])</p></td>
<td><p>Set the module in training mode.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code>(dst_type)</p></td>
<td><p>Casts all parameters and buffers to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dst_type</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">xpu</span></code>([device])</p></td>
<td><p>Move all model parameters and buffers to the XPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zero_grad</span></code>([set_to_none])</p></td>
<td><p>Reset gradients of all model parameters.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>__call__</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_pyr_to_tensor">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convert_pyr_to_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pyr_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/steerable_pyramid_freq.html#SteerablePyramidFreq.convert_pyr_to_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_pyr_to_tensor" title="Link to this definition"></a></dt>
<dd><p>Convert coefficient dictionary to a tensor.</p>
<p>The output tensor has shape (batch, channel, height, width) and is
intended to be used in an <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> downstream. In the
multichannel case, all bands for each channel will be stacked together
(i.e. if there are 2 channels and 18 bands per channel,
pyr_tensor[:,0:18,…] will contain the pyr responses for channel 1 and
pyr_tensor[:, 18:36, …] will contain the responses for channel 2). In
the case of a complex, multichannel pyramid with split_complex=True,
the real/imaginary bands will be intereleaved so that they appear as
pairs with neighboring indices in the channel dimension of the tensor
(Note: the residual bands are always real so they will only ever have a
single band even when split_complex=True.)</p>
<p>This only works if <code class="docutils literal notranslate"><span class="pre">pyr_coeffs</span></code> was created with a pyramid with
<code class="docutils literal notranslate"><span class="pre">downsample=False</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyr_coeffs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></span>) – the pyramid coefficients</p></li>
<li><p><strong>split_complex</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – indicates whether the output should split complex bands into
real/imag channels or keep them as a single channel. This should be
True if you intend to use a convolutional layer on top of the
output.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code>[<code class="docutils literal notranslate"><span class="pre">'residual_lowpass'</span></code>, <code class="docutils literal notranslate"><span class="pre">'residual_highpass'</span></code>]]]]]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>pyr_tensor</em> – shape (batch, channel, height, width). pyramid coefficients
reshaped into tensor. The first channel will be the residual
highpass and the last will be the residual lowpass. Each band is
then a separate channel.</p></li>
<li><p><em>pyr_info</em> – Information required to recreate the dictionary, containing the
number of channels, if split_complex was used in this function
call, and the list of pyramid keys for the dictionary</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_tensor_to_pyr" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_tensor_to_pyr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_tensor_to_pyr</span></code></a></dt><dd><p>Convert tensor representation to pyramid dictionary.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_tensor_to_pyr">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">convert_tensor_to_pyr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pyr_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_complex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pyr_keys</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/steerable_pyramid_freq.html#SteerablePyramidFreq.convert_tensor_to_pyr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_tensor_to_pyr" title="Link to this definition"></a></dt>
<dd><p>Convert pyramid coefficient tensor to dictionary format.</p>
<p><code class="docutils literal notranslate"><span class="pre">num_channels</span></code>, <code class="docutils literal notranslate"><span class="pre">split_complex</span></code>, and <code class="docutils literal notranslate"><span class="pre">pyr_keys</span></code> are elements of
the <code class="docutils literal notranslate"><span class="pre">pyr_info</span></code> tuple returned by <code class="docutils literal notranslate"><span class="pre">convert_pyr_to_tensor</span></code>. You
should always unpack the arguments for this function from that
<code class="docutils literal notranslate"><span class="pre">pyr_info</span></code> tuple. Example Usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyr_tensor</span><span class="p">,</span> <span class="n">pyr_info</span> <span class="o">=</span> <span class="n">convert_pyr_to_tensor</span><span class="p">(</span><span class="n">pyr_coeffs</span><span class="p">,</span> <span class="n">split_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">pyr_dict</span> <span class="o">=</span> <span class="n">convert_tensor_to_pyr</span><span class="p">(</span><span class="n">pyr_tensor</span><span class="p">,</span> <span class="o">*</span><span class="n">pyr_info</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyr_tensor</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></span>) – Shape (batch, channel, height, width). The pyramid coefficients</p></li>
<li><p><strong>num_channels</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – number of channels in the original input tensor the pyramid was
created for (i.e. if the input was an RGB image, this would be 3)</p></li>
<li><p><strong>split_complex</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – true or false, specifying whether the pyr_tensor was created with
complex channels split or not (if the pyramid was a complex
pyramid).</p></li>
<li><p><strong>pyr_keys</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code>[<code class="docutils literal notranslate"><span class="pre">'residual_lowpass'</span></code>, <code class="docutils literal notranslate"><span class="pre">'residual_highpass'</span></code>]]]</span>) – tuple containing the list of keys for the original pyramid dictionary</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pyramid coefficients in dictionary format</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pyr_coeffs</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_pyr_to_tensor" title="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.convert_pyr_to_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_pyr_to_tensor</span></code></a></dt><dd><p>Convert pyramid dictionary representation to tensor.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scales</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/steerable_pyramid_freq.html#SteerablePyramidFreq.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.forward" title="Link to this definition"></a></dt>
<dd><p>Generate the steerable pyramid coefficients for an image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></span>) – A tensor containing the image to analyze. We want to operate
on this in the pytorch-y way, so we want it to be 4d (batch,
channel, height, width).</p></li>
<li><p><strong>scales</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code>[<code class="docutils literal notranslate"><span class="pre">'residual_lowpass'</span></code>, <code class="docutils literal notranslate"><span class="pre">'residual_highpass'</span></code>]]]]</span>) – Which scales to include in the returned representation. If None, we
include all scales. Otherwise, can contain subset of values present
in this model’s <code class="docutils literal notranslate"><span class="pre">scales</span></code> attribute (ints from 0 up to
<code class="docutils literal notranslate"><span class="pre">self.num_scales-1</span></code> and the strs ‘residual_highpass’ and
‘residual_lowpass’. Can contain a single value or multiple values.
If it’s an int, we include all orientations from that scale. Order
within the list does not matter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pyramid coefficients</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>representation</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.recon_pyr">
<span class="sig-name descname"><span class="pre">recon_pyr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pyr_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/steerable_pyramid_freq.html#SteerablePyramidFreq.recon_pyr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.recon_pyr" title="Link to this definition"></a></dt>
<dd><p>Reconstruct the image or batch of images, optionally using subset of pyramid coefficients.</p>
<p>NOTE: in order to call this function, you need to have
previously called <cite>self.forward(x)</cite>, where <cite>x</cite> is the tensor you
wish to reconstruct. This will fail if you called <cite>forward()</cite>
with a subset of scales.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyr_coeffs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></span>) – pyramid coefficients to reconstruct from</p></li>
<li><p><strong>levels</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code>[<code class="docutils literal notranslate"><span class="pre">'all'</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code>[<code class="docutils literal notranslate"><span class="pre">'residual_lowpass'</span></code>, <code class="docutils literal notranslate"><span class="pre">'residual_highpass'</span></code>]]]]</span>) – If <cite>list</cite> should contain some subset of integers from <cite>0</cite> to
<cite>self.num_scales-1</cite> (inclusive), <cite>‘residual_lowpass’</cite>, and
<cite>‘residual_highpass’</cite>. If <cite>‘all’</cite>, returned value will contain all
valid levels. Otherwise, must be one of the valid levels.</p></li>
<li><p><strong>bands</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code>[<code class="docutils literal notranslate"><span class="pre">'all'</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – If list, should contain some subset of integers from <cite>0</cite> to
<cite>self.num_orientations-1</cite>. If <cite>‘all’</cite>, returned value will contain
all valid orientations. Otherwise, must be one of the valid
orientations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The reconstructed image, of shape (batch, channel, height, width)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>recon</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.steer_coeffs">
<span class="sig-name descname"><span class="pre">steer_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pyr_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/plenoptic/simulate/canonical_computations/steerable_pyramid_freq.html#SteerablePyramidFreq.steer_coeffs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#plenoptic.simulate.canonical_computations.steerable_pyramid_freq.SteerablePyramidFreq.steer_coeffs" title="Link to this definition"></a></dt>
<dd><p>Steer pyramid coefficients to the specified angles</p>
<p>This allows you to have filters that have the Gaussian derivative order specified in
construction, but arbitrary angles or number of orientations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyr_coeffs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></span>) – the pyramid coefficients to steer</p></li>
<li><p><strong>angles</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) – list of angles (in radians) to steer the pyramid coefficients to</p></li>
<li><p><strong>even_phase</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – specifies whether the harmonics are cosine or sine phase aligned about those positions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>resteered_coeffs</em> – dictionary of re-steered pyramid coefficients. will have the same
number of scales as the original pyramid (though it will not
contain the residual highpass or lowpass). like <cite>pyr_coeffs</cite>, keys
are 2-tuples of ints indexing the scale and orientation, but now
we’re indexing <cite>angles</cite> instead of <cite>self.num_orientations</cite>.</p></li>
<li><p><em>resteering_weights</em> – dictionary of weights used to re-steer the pyramid coefficients.
will have the same keys as <cite>resteered_coeffs</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-plenoptic.simulate.canonical_computations">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-plenoptic.simulate.canonical_computations" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="plenoptic.simulate.html" class="btn btn-neutral float-left" title="plenoptic.simulate package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="plenoptic.simulate.models.html" class="btn btn-neutral float-right" title="plenoptic.simulate.models package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Plenoptic authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>